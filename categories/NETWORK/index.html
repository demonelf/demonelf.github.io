<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Category: NETWORK | 芯机智</title>
  
  

  
  <link rel="alternate" href="/atom.xml" title="芯机智">
  

  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css">
  

  

  
    <link rel="stylesheet" href="/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  
  <header class="l_header pure">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="pure"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='/' >
        
          芯机智
        
      </a>
			<div class='menu navgation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                  id="home">
									<i class='fas fa-home fa-fw'></i>&nbsp;主页
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/"
                  
                    rel="nofollow"
                  
                  
                  id="categories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/tags/"
                  
                    rel="nofollow"
                  
                  
                  id="blogtags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/archives/"
                  
                    rel="nofollow"
                  
                  
                  id="blogarchives">
									<i class='fas fa-archive fa-fw'></i>&nbsp;归档
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索" />
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/blog/archives/"
                
                  rel="nofollow"
                
                
                id="blogarchives">
								<i class='fas fa-archive fa-fw'></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/projects/"
                
                
                id="projects">
								<i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/friends/"
                
                  rel="nofollow"
                
                
                id="friends">
								<i class='fas fa-link fa-fw'></i>&nbsp;我的友链
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="https://xaoxuu.com/wiki/material-x/"
                
                  rel="nofollow"
                
                
                id="https:xaoxuu.comwikimaterial-x">
								<i class='fas fa-book fa-fw'></i>&nbsp;主题文档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      
<div class='l_main'>
  
    
      
  <section class="post-list">
    
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
    
    
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/NETWORK/Gentoo下利用pptpd搭建PPTP服务器 .html">
      Gentoo下利用pptpd搭建PPTP服务器
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://demonelf.github.io" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>madhex</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-08-29</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/NETWORK/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>NETWORK</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>首先检查当前系统的linux kernel有没有支持ppp, netfilter, mppe和 netfilter的nat,如果没有，请先配置支持这些组建，编译更新内核，然后重启系统。这块不再详述，如果想知道详细情况，可以留言问我。<br>接着安装必要软件</p>
<blockquote>
<p>emerge ppp</p>
<p>emerge pptpd</p>
</blockquote>
<p>然后修改配置文件<br>先是pptpd的配置文件 /etc/pptpd.conf</p>
<pre><code>ppp /usr/sbin/pppd
option /etc/ppp/options.pptpd
logwtmp
localip 172.16.0.1
remoteip 172.16.0.2-254
</code></pre>
      
        <div class="readmore">
          <a href="/NETWORK/Gentoo下利用pptpd搭建PPTP服务器 .html" class="flat-box">
            <i class="fas fa-book-open fa-fw" aria-hidden="true"></i>
            阅读全文
          </a>
        </div>
      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/linux/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>linux</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/NETWORK/Socks代理反弹突破内网.html">
      Socks代理反弹突破内网
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://demonelf.github.io" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>madhex</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-08-28</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/NETWORK/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>NETWORK</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p><strong>随着信息安全意识的提升，越来越多的信息系统前端均部署有防火墙，系统管理员根据业务需求将内部必要的服务端口通过端口映射等手段映射到公网中，如默认**</strong>web<strong>服务端口</strong>80<strong>、</strong>MSSQL<em>*数据库服务端口</em>1433等。通过部署防火墙可以将信息系统内部区域与公网逻辑隔离开来，利用相关的策略有效避免或减轻来自外部的攻击。</p>
<p>对于渗透测试者来说，如何绕过防火墙的阻挡在内网展开渗透测试成为亟需解决的问题，本文介绍了在夺取映射到外网的内网服务器权限后，如何利用socks代理反弹获得内网访问权限。</p>
<p>1.sSocks</p>
<p>sSocks是一个<a href="http://www.freebuf.com/news/topnews/111545.html" target="_blank" rel="external">socks代理</a>工具套装，可用来开启socks代理服务，支持socks5验证，支持IPV6和UDP，并提供反向socks代理服务，即将远程计算机作为socks代理服务端，反弹回本地，极大方便内网的渗透测试，其最新版为0.0.13，可在以下链接处下载。</p>
<p><a href="http://sourceforge.net/projects/ssocks/" target="_blank" rel="external">http://sourceforge.net/projects/ssocks/</a></p>
<p>下载解压后，执行命令编译。</p>
<pre><code>./configure &amp;&amp; make
</code></pre><p>编译完成，进入src目录，会发现有nsocks、ssocksd、ssocks、rcsocks，其功能说明介绍如下：</p>
<p>程序 功能<br><strong>nsocks</strong> 类似通过Socks5代理后的netcat，可用来测试socks server<br><strong>ssocksd</strong> 用来开启Socks5代理服务<br><strong>ssocks</strong> 本地启用Socks5服务，并反弹到另一IP地址<br><strong>rcsocks</strong> 接收反弹过来的Socks5服务，并转向另一端口</p>
<p><strong>2.模拟网络环境说明</strong></p>
<p> 本文模拟的网络环境见下图1，渗透测试端IP为192.168.10.50，内网区域IP段192.168.206.0/24，内网区域能正常访问192.168.10.0/24，现假设已获得192.168.206.130权限。 </p>
<p><a href="http://image.3001.net/uploads/image/20130901/20130901105859_75679.jpg" target="_blank" rel="external"><img src="http://image.3001.net/uploads/image/20130901/20130901105859_75679.jpg" alt="模拟的网络环境"></a></p>
<p><strong>3.实施Socks代理反弹</strong><br><strong>1)本地监听端口</strong><br>在渗透测试端192.168.10.50执行</p>
<pre><code>./rcsocks -l 1088 -p 1080 -vv
</code></pre><p>等待远程Socks5服务器访问本地1080端口，创建端口1080与本地端口1088的连接通道，如图2。 </p>
<p><a href="http://image.3001.net/uploads/image/20130901/20130901105926_77843.jpg" target="_blank" rel="external"><img src="http://image.3001.net/uploads/image/20130901/20130901105926_77843.jpg" alt="Socks代理反弹突破内网"></a></p>
<p><strong>2)开启Socks5代理服务，反弹</strong><br>在192.168.206.130上执行</p>
<pre><code>./rssocks -vv -s 192.168.10.50:1080
</code></pre><p>启用Socks5服务，反弹到192.168.10.50的端口1080上，如图3。 </p>
<p><a href="http://image.3001.net/uploads/image/20130901/20130901110001_38329.jpg" target="_blank" rel="external"><img src="http://image.3001.net/uploads/image/20130901/20130901110001_38329.jpg" alt="开启Socks5代理服务，反弹"></a></p>
<p>此时在渗透测试端192.168.10.50可看到通道连接成功，效果如图4。</p>
<p><a href="http://image.3001.net/uploads/image/20130901/20130901110020_58042.jpg" target="_blank" rel="external"><img src="http://image.3001.net/uploads/image/20130901/20130901110020_58042.jpg" alt="通道连接成功"></a></p>
<p><strong>4.利用proxychains进行Socks5代理</strong><br>通过前面的步骤，Socks5代理已创建完成了。由于在渗透测试过程中，需要使用不同的工具程序，而在各程序中分别配置Socks5代理信息较为繁琐，而部分程序并不支持配置Socks5代理。为了简化这些操作，我们可以采用proxychains。<br>proxychains是一个代理客户端软件，可以支持几乎所有程序的代理，如ssh，telnet，ftp等。利用proxychains，程序能在代理的环境下被加载运行，而本身不需要具备代理功能。使用前需要对proxychains进行简单配置，打开配置文件proxychains.conf（在BT5位于/etc/proxychains.conf），如图5所示，在[ProxyList]处添加<br><strong>socks5 127.0.0.1 1088</strong></p>
<p><a href="http://image.3001.net/uploads/image/20130901/20130901110043_92020.jpg" target="_blank" rel="external"><img src="http://image.3001.net/uploads/image/20130901/20130901110043_92020.jpg" alt="利用proxychains进行Socks5代理"></a></p>
<p>配置成功后若要启动程序，仅需要在启动程序命令前加上proxychains。<br><strong>1)启用浏览器firefox，在终端执行命令：</strong></p>
<pre><code>proxychains firefox
</code></pre><p>firefox启动成功，访问192.168.206.135的web服务如图6，通过代理访问成功。</p>
<p><a href="http://image.3001.net/uploads/image/20130901/20130901110125_93242.jpg" target="_blank" rel="external"><img src="http://image.3001.net/uploads/image/20130901/20130901110125_93242.jpg" alt="通过代理访问成功"></a></p>
<p><strong>2)利用sqlmap进行注入：</strong><br>先切换到sqlmap目录<br>cd /pentest/database/sqlmap<br>proxychains python sqlmap.py -u “存在SQL注入的链接” –dbs<br>注入成功，注入点信息及获取数据库信息如图7所示。</p>
<p><a href="http://image.3001.net/uploads/image/20130901/20130901110208_52827.jpg" target="_blank" rel="external"><img src="http://image.3001.net/uploads/image/20130901/20130901110208_52827.jpg" alt="利用sqlmap进行注入"></a></p>
<p><strong>5.后记</strong><br>由于系统管理员的疏忽或者业务需求所致，防火墙一般仅对由外向内发起的数据连接进行严格判断、过滤、甚至阻断而忽略由内往外的连接。因此，在此种情况下，通过攻陷映射到公网的端口服务，利用反弹便可获取内网访问权限，给内网安全带来极大的威胁。在信息安全建设与运维过程中，不仅要加强映射到公网的服务安全，也要重视由内到外连接的安全威胁。</p>

      
    </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/NETWORK/关于linux 802.1d (bridge) 和 802.1q(vlan) 实现的再思考.html">
      关于linux 802.1d (bridge) 和 802.1q(vlan) 实现的再思考
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://demonelf.github.io" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>madhex</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2017-12-07</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/NETWORK/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>NETWORK</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>​    linux bridge - (brctl)实现了ieee 802.1d协议，这个实现，应该是不能支持VLAN的功能。也就是说，这个实现，只能承载一个广播域，而不能承载多个广播域。当然，可以创建多个bridge device，每个bridge都对应不同的vlan，在bridge内部，包通过fdb表来转发，但是这个fdb表里面并没有vlan的信息。如果要在多个bridge device之间通信，比必须在bridge device上创建vlan interface，然后配置路由，这样可以实现不同bridge之间的转发。<br>​    linux vlan - (vconfig)实现了ieee 802.1q协议。802.1q本来应该是一个二层协议，但是linux的实现需要创建vlan interface,而且可以在vlan interface上配置ip地址。所以，这个interface可以放到路由表里面。一般来说，在这个interface上收到的包，会带这个interface配置的vlan id，而从这个interface发出去的包，会打上这个interface的vlan id.</p>
<p>​    举一个例子。一个盒子有6个物理interface, eth0,eth1,eth2,eth3,eth4,eth5,eth6.<br>​    bridge0 { eth0, eth1, eth2 }, vlan id 是2<br>​    bridge1 { eth3, eth4, eth5 }, vlan id 是3<br>​    eth0,eth1,eth2,eth3,eth4,eth5都在混杂模式，并且没有ip地址，它们是bridge的port.<br>​    创建vlan interface, bridge0.2, bridge1.3。在bridge0.2和bridge1.3上配置ip地址。vlan 2的机器，把bridge0.2的地址设置为缺省网关；vlan 3的机器，把bridge1.3设置为缺省网关。当有包要从vlan 2发往vlan 3是，它将送到bridge0.2，然后，通过路由，找到bridge1.3，然后由bridge1.3发出去。这个过程中，packet里面的vlan id会发生改变。<br>​    这个例子里面，要求从bridge port上收到的包都必须是打tag的，在bridge里面，并不能识别和处理tag，只有到三层的vlan interface才能识别并处理这些tag.<br>在bridge是还会运行STP协议来消除回环，进而实现了link一级的HA。STP，RSTP都是没有vlan的概念，而后来的PVST,PVST+，以及MSTP等，都能识别vlan，并且能消除一个vlan里面的回环。</p>
<p>关于Bridge，可以参考：<a href="http://www.linuxfoundation.org/en/Net:Bridge" target="_blank" rel="external">http://www.linuxfoundation.org/en/Net:Bridge</a><br>关于Vlan,可以参考：<a href="http://www.candelatech.com/~greear/vlan.html" target="_blank" rel="external">http://www.candelatech.com/~greear/vlan.html</a><br>关于STP，可以参考：<a href="http://en.wikipedia.org/wiki/Spanning_tree_protocol" target="_blank" rel="external">http://en.wikipedia.org/wiki/Spanning_tree_protocol</a></p>
<p>posted on 2011-03-23 18:04 flyonok</p>

      
    </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/NETWORK/三层交换机路由设计方案.html">
      三层交换机路由设计方案
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://demonelf.github.io" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>madhex</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2017-09-29</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/NETWORK/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>NETWORK</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <iframe src="http://docs.google.com/viewer?url=http://www.madhex.com/NETWORK/三层交换机路由设计方案.doc&embedded=true" width="100%" height="480" scrolling="no" style="border: none;"></iframe>
      
    </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/NETWORK/nat穿透.html">
      nat穿透
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://demonelf.github.io" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>madhex</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2017-09-27</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/NETWORK/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>NETWORK</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p><img src="nat分类.png" alt=""></p>
<p>作者：陈军链接：<a href="https://www.zhihu.com/question/38729355/answer/77877260" target="_blank" rel="external">https://www.zhihu.com/question/38729355/answer/77877260</a></p>
<p>来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。      </p>
<p>​    NAT分为两大类，基本的NAT和NAPT（Network Address/Port Translator）。<br>基本的NAT，它仅将内网主机的私有IP地址转换成公网IP地址，但并不将TCP/UDP端口信息进行转换，有动态与静态之区分。由于现在大部分都属于另一种类型，即NAPT，故这里不详细讨论基础NAT。 另外一种NAT叫做NAPT（Network Address/Port Translator），从名称上我们也可以看得出，NAPT不但会改变经过这个NAT设备的IP数据报的IP地址，还会改变IP数据报的TCP/UDP端口。</p>
<p>​      NAPT又分为锥型（Cone）和对称型（Symmetric），它们的区别在于，在NAT已分配端口号给Client A的情况下，如果Client A继续用1235端口与另一外网服务器通讯，锥型NAT还会继续用原来62000端口，即所分配的端口号不变。而对于对等型NAT，NAT将会分配另一端口号（如62001）给Client A的1235端口。也就是说，同一内网主机同一端口号，对于锥型NAT，无论与哪一外网主机通讯，都不改变所分配的端口号；而对于对等型NAT，同一内网主机同一端口号，每一次与不同的外网主机通讯，就重新分配另一个端口号。 </p>
<p>​    目前比较常用的NAT类型是完全锥型NAT。</p>
<ol>
<li>首先目前绝大多数的路由器都是非对称型NAT(Cone NAT)，所以P2P技术才能正常使用。 对称/非对称的区别主要在于：网关设备在实现NAT时，对于内网某主机的若干个UDP连接请求，网关设备对应地在外网上所建立的UDP端口数量。对称NAT是一个请求对应一个端口，非对称NAT是多个请求对应一个端口(象锥形，所以叫Cone NAT)。</li>
<li>对称型NAT(Symmetric NAT)是无法实现P2P技术。 </li>
</ol>
<p>​    对于两方都是对称nat的情况，至少从可以了解的途径上（比如google，相关论坛）都没找到解决方案，我们自己也进行过测试，不行。</p>
<p>​    但是对于一端是对称nat，一端是端口限制性Cone nat的情况是可以打洞成功的，特别是我们实验的对称nat的端口变化还是有规律的（加1），我们使用端口猜测的方法进行打洞成功率还是非常高的。对于端口变化无规律的对称nat，这个猜测还是靠算法的设计，</p>
<p>可以看看<strong>A New Method for Symmetric NAT Traversal </strong>in UDP and TCP </p>
<p>（<a href="http://www.goto.info.waseda.ac.jp/~wei/file/wei-apan-v10.pdf）" target="_blank" rel="external">http://www.goto.info.waseda.ac.jp/~wei/file/wei-apan-v10.pdf）</a></p>

      
    </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/NETWORK/静态路由使用下一跳IP与出接口的区别.html">
      静态路由使用下一跳IP与出接口的区别
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://demonelf.github.io" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>madhex</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2017-09-22</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/NETWORK/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>NETWORK</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>配置下一跳为出接口的</p>
<p>好处是不用知道下一跳具体ip可以实现动态学习的效果</p>
<p>缺点在于下一跳路由器必须支持这种基本的arp代理功能.</p>
<p>拓扑图： <a href="http://img1.51cto.com/attachment/201308/210834964.png" target="_blank" rel="external"><img src="http://img1.51cto.com/attachment/201308/210834964.png" alt=""></a><br>以太网链路中：两个接口之间的通信是靠MAC地址，根据MAC地址，将数据封装成数据帧后传送到网络，进而通过物理线路传送给对方。而获取到对端的MAC地址，是通过ARP来完成的。<br>例：1，当静态路由中下一跳使用出接口时，路由器会认为目标网络和接口处在“直连网络”中。如：R1(config)#ip route 192.168.2.0 255.255.255.0f0/0查看路由表：R1#show ip route  <a href="http://img1.51cto.com/attachment/201308/210834122.png" target="_blank" rel="external"><img src="http://img1.51cto.com/attachment/201308/210834122.png" alt=""></a><br>在以太网直连网络中设备间的通信是靠ARP广播来获取到目标主机的MAC地址。即当R1要访问192.168.2.2这个ip地址时，R1会认为目标网络是和自己直连的（虽然这时候实际是静态路由），于是R1就要在F0/0口向网络发出ARP请求广播，来寻找192.168.2.2所对应的MAC地址。<br>这时，如果R2启用了ARP代理，那么R2将代替R3应答此ARP请求，即R2告诉R1：192.168.2.2所对应的MAC地址是R2的F0/0接口的MAC。如果R2的ARP代理功能关闭，那么R1将不能ping通192.168.2.2<br>使用出接口的弊端：如果R3后面接了些pc机，当R1要访问这些pc机时，都会产生一条该pc机和MAC地址对应的ARP条目缓存，如果pc机的数量很大，此缓存也会很大，会导致R1耗费很大内存来维护。<br>2，当静态路由中下一跳使用ip地址时，路由表中显示的是下一跳地址。如：R1(config)#ip route 192.168.2.0 255.255.255.0 192.168.1.2查看路由表：R1#show ip route  <a href="http://img1.51cto.com/attachment/201308/210835833.png" target="_blank" rel="external"><img src="http://img1.51cto.com/attachment/201308/210835833.png" alt=""></a><br>这时去往192.168.2.2的网段只会维护一条ARP缓存，即192.168.1.2所对一个的是R2的F0/0接口地址。即使R3后面接了多台主机，也只需要维护这么一条ARP缓存记录。<br>二：点到点网络环境下：无论是指定下一跳地址还是出接口，都是一样的。因为这种环境下使用HDLC和PPP等协议来进行二层封装，不需要进行ARP的解析。<br>结论：1、在点到点网络环境下，无论是指定下一跳地址还是出接口，都是一样的2、在广播网络环境下，则不然。如果指定为出接口的话，那么不管数据包的目标地址是否有效，每次当数据包到达时都会触发一个ARP请求，又因为ARP代理功能在IOS环境下默认是打开的，这就意味着路由器需要配置大量的ARP高速缓存。而如果是指定为下一跳地址的话，仅当第一个去往目标网络的数据包到达时，才会触发ARP请求。<br>本文出自 “天好” 博客，请务必保留此出处<a href="http://tianhaoblog.blog.51cto.com/6467511/1280163" target="_blank" rel="external">http://tianhaoblog.blog.51cto.com/6467511/1280163</a></p>

      
    </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/NETWORK/使用ARP的四种典型情况.html">
      使用ARP的四种典型情况
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://demonelf.github.io" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>madhex</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2017-09-22</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/NETWORK/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>NETWORK</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>使用ARP的四种典型情况</p>
<p>1.发送方是主机，把IP数据包发送到本网络上的另一个主机。这时用ARP找到目的主机的硬件MAC地址。  </p>
<p>2.发送方是主机，要把IP数据报发送到另一个网络上的主机。这时用ARP找到本网络上的一个<a href="https://www.2cto.com/net/router/" target="_blank" rel="external">路由器</a>（网关）的硬件MAC地址。剩下的工作由这个路由器来完成。 </p>
<p>3.发送方是路由器，要把IP数据报转发到本网络上的一个主机。这时用ARP找到目的主机的硬件MAC地址 </p>
<p>4.发送方是路由器，要把IP数据报转发到另一个网络的一个主机。这时用ARP找到本网络上的一个路由器（网关）的硬件地址。剩下的工作有这个路由器来完成。</p>
<p>主机和路由器表现的行为是一致的，区别在于，路由器可以作为网关，而PC不可以。当要把IP数据报转发另一个网络的一个主机时，ARP找到本网络上的一个网关的硬件MAC地址，这个网关可以是路由器，也可以是三层<a href="https://www.2cto.com/net/switch/" target="_blank" rel="external">交换机</a>。</p>
<p>纯二层交换机是没有ARP表项的。交换机是否有ARP表项取决于交换机是否作为三层设备（配置三层路由接口或SVI接口）</p>
<p>网络层使用的是IP地址，但在实际网络的链路上传送数据帧时，最终必须使用该网络的硬件地址。 </p>
<p>每一个主机都设有一个ARP高速缓存，里面有本局域网上的各主机和网关的IP地址到硬件地址的映射表。也就是说，一个主机可以通过ARP到本局域网的其他主机，到达其他网络主机的工作交给网关完成。</p>
<p>同一子网 源目mac地址都不会改变 </p>
<p>不同子网 源目IP地址都不会改变，改变源目MAC地址</p>

      
    </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/NETWORK/4G路由器移植pptp方案总结.html">
      4G路由器移植pptp方案总结
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://demonelf.github.io" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>madhex</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2017-08-17</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/NETWORK/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>NETWORK</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="pppoe总框架原理"><a href="#pppoe总框架原理" class="headerlink" title="pppoe总框架原理"></a>pppoe总框架原理</h3><p><img src="PPP框架原理.jpg" alt=""></p>
<h3 id="pptp总框架原理"><a href="#pptp总框架原理" class="headerlink" title="pptp总框架原理"></a>pptp总框架原理</h3><p><img src="pptp原理框架.JPG" alt=""></p>
<h2 id="ppp可行性分析"><a href="#ppp可行性分析" class="headerlink" title="ppp可行性分析"></a>ppp可行性分析</h2><h3 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h3><p>​    现需要在我们自己公司的4G路由器上移植pptp功能. 4G路由器硬件为mips.本来只需把开源的pptp和pppd编译对应的mips版本即可.但是由于4G路由本身有一套ppp库代码.为了实现软件的优化和可控性,我们想把开源的pptp和我们系统已有的ppp库实现融合. 由于ppp库没有使用手册,并且想要修改pptp实现各种我们需要的定制功能,例:按需拨号,自动重连等功能.我们先需要分析ppp vpn框架原理和ppp代码实现.来完成我们的pptp项目软件设计.</p>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>​    一 需要捋顺整个ppp相关框架也就是以上框架图,同时还要掌握框架中用到的内核关键结构体和index,应用用到的fd等.</p>
<p>​    二 需要掌握pppd的协议状态机.</p>
<h3 id="tty简介"><a href="#tty简介" class="headerlink" title="tty简介"></a>tty简介</h3><p>首先需熟悉tty驱动框架,然后再分析ppp是如何结合tty框架实现的.</p>
<p>整个 uart 框架大概的样子如上图所示，简单来分的话可以说成两层，一层是下层我们的串口驱动层，它直接与硬件相接触，我们需要填充一个 struct uart_ops 的结构体，另一层是上层 tty 层，包括 tty 核心以及线路规程，它们各自都有一个 Ops 结构，用户空通过间是 tty 注册的字符设备节点来访问，这么说来如上图所示涉及到了4个 ops 结构了，层层跳转。。</p>
<p><img src="tty驱动框架.gif" alt=""></p>
<h3 id="ppp内核态tty框架实现代码"><a href="#ppp内核态tty框架实现代码" class="headerlink" title="ppp内核态tty框架实现代码"></a>ppp内核态tty框架实现代码</h3><p>ppp利用了tty中的规程层,实现了通过tty截获与发送数据.</p>
<p>在PPP驱动程序中, </p>
<p>每一tty终端设备对应于一条PPP传输通道(channel), </p>
<p>每一ppp网络设备对应于一个PPP接口单元(unit)</p>
<h4 id="ppp内核态重要结构体"><a href="#ppp内核态重要结构体" class="headerlink" title="ppp内核态重要结构体"></a>ppp内核态重要结构体</h4><pre><code class="c">struct channel{
    struct ppp /*包含struct ppp_file而ppp_file中包含index*/
    struct ppp_channel/*也包含struct channel*/
} /*generic定义*/

struct ppp {
    struct ppp_file    file;
}/*generic定义*/

struct ppp_file {
    int index;
}/*generic定义*/

struct asyncppp{
    struct ppp_channel/*包含struct channel找到index*/
}/*ppp_async定义 ppp_asynctty_open中初始化*/

ppp_asynctty_open初始化了
{
    struct asyncppp
    struct ppp_channel
    struct channel
    struct ppp_file
}
/*此函数很关键,要掌握如何调用此函数,也就更熟悉pppd初始化原理了*/
/*ppp_asynctty_open初始化了以上大部分结构体*/
/*调用此ppp_asynctty_open函数的位置比较隐蔽*/
/*是在pppd通过ioctl绑定规程时内核函数tty_set_ldisc中调用了此函数*/
/*以上结构体都初始化好后,pppd就可以通过/dev/ppp绑定channel_id了*/
</code></pre>
<h4 id="pppd摘要代码框架"><a href="#pppd摘要代码框架" class="headerlink" title="pppd摘要代码框架"></a>pppd摘要代码框架</h4><pre><code class="c">int main(argc, argv){
      /*配置参数*/
      ...
    magic_init();
    /* Initialize each protocol.*/
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
        (*protp-&gt;init)(0);
    /*创建虚拟接口*/
    ppp_available();
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
        if (protp-&gt;check_options != NULL)
            (*protp-&gt;check_options)();
    if (the_channel-&gt;check_options)
        (*the_channel-&gt;check_options)();
      /*进入状态机*/
    for (;;) {
          lcp_open(0);        /* Start protocol */
          start_link(0);
          while (phase != PHASE_DEAD) {
        }
        lcp_close(0, &quot;&quot;);
    }
}
</code></pre>
<h4 id="ppp框架中的-tty用户层"><a href="#ppp框架中的-tty用户层" class="headerlink" title="ppp框架中的(tty用户层)"></a>ppp框架中的(tty用户层)</h4><pre><code class="c">//在tty_register_device中注册
</code></pre>
<h4 id="ppp框架中的-tty核心层"><a href="#ppp框架中的-tty核心层" class="headerlink" title="ppp框架中的(tty核心层)"></a>ppp框架中的(tty核心层)</h4><pre><code class="c">//在注册驱动层中注册的核心层  
1、为线路规程和termios分配空间，并使 tty_driver 相应的成员指向它们。
2、注册字符设备，名字是 uart_driver-&gt;name 我们这里是“ttySAC”,文件操作函数集是 tty_fops。
3、将该 uart_driver-&gt;tty_drivers 添加到全局链表 tty_drivers 。
4、向 proc 文件系统添加 driver ，这个暂时不了解。
int tty_register_driver(struct tty_driver *driver)  
{  
    tty_register_device(driver, i, NULL);  
    return 0;  
}
</code></pre>
<h4 id="ppp框架中的-tty规程层"><a href="#ppp框架中的-tty规程层" class="headerlink" title="ppp框架中的(tty规程层)"></a>ppp框架中的(tty规程层)</h4><pre><code class="c">ppp_async.c
static struct tty_ldisc_ops ppp_ldisc = {
    .owner  = THIS_MODULE,
    .magic    = TTY_LDISC_MAGIC,
    .name    = &quot;ppp&quot;,
    .open    = ppp_asynctty_open,
    .close    = ppp_asynctty_close,
    .hangup    = ppp_asynctty_hangup,
    .read    = ppp_asynctty_read,
    .write    = ppp_asynctty_write,
    .ioctl    = ppp_asynctty_ioctl,
    .poll    = ppp_asynctty_poll,
    .receive_buf = ppp_asynctty_receive,
    .write_wakeup = ppp_asynctty_wakeup,
};

static int __init
ppp_async_init(void)
{
    /*注册tty规程*/
    err = tty_register_ldisc(N_PPP, &amp;ppp_ldisc);
}

/*创建channel*/
static int ppp_asynctty_open(struct tty_struct *tty)
{

}

static int ppp_asynctty_ioctl(struct tty_struct *tty, struct file *file,
           unsigned int cmd, unsigned long arg)
{
    switch (cmd) {
    case PPPIOCGCHAN:   //获取channel
    case PPPIOCGUNIT:   //
    case TCFLSH:
    case FIONREAD:
    }
}
</code></pre>
<h4 id="ppp框架中的-tty驱动层"><a href="#ppp框架中的-tty驱动层" class="headerlink" title="ppp框架中的(tty驱动层)"></a>ppp框架中的(tty驱动层)</h4><pre><code class="c">pty.c  
1、根据driver支持的最大设备数，申请n个 uart_state 空间，每一个 uart_state 都有一个 uart_port 。
2、分配一个 tty_driver ，并将drv-&gt;tty_driver 指向它。
3、对 tty_driver 进行设置，其中包括默认波特率、校验方式等，还有一个重要的 Ops ，uart_ops ，它是tty核心与我们串口驱动通信的接口。
4、初始化每一个 uart_state 的 tasklet 。
5、注册 tty_driver 。
pty_init()
{
    tty_set_operations(pty_driver, &amp;pty_ops);
    tty_register_driver(pty_driver);
}
</code></pre>
<p>​    </p>
<pre><code class="c">ppp_register_net_channel() {
    init_ppp_file(&amp;pch-&gt;file, CHANNEL);
}
ppp_create_interface(){
    init_ppp_file(&amp;ppp-&gt;file, INTERFACE);  
}
</code></pre>
<blockquote>
<p>ppp只需通过pptp知道一个tty_dev就可以了</p>
</blockquote>
<h3 id="pppd配置参数"><a href="#pppd配置参数" class="headerlink" title="pppd配置参数"></a>pppd配置参数</h3><h4 id="pppd相关fd"><a href="#pppd相关fd" class="headerlink" title="pppd相关fd"></a>pppd相关fd</h4><pre><code class="c">    /*/dev/pty/n 1.绑定规程 2.获取chindex 
    connect_tty中第二创建*/
    ppp_cfg[unit]-&gt;dev_fd = ppp_info-&gt;ttyfd; 

    /*/dev/ppp CHANNEL 
    pptp_setup_ppp中第三创建*/
    ppp_cfg[unit]-&gt;lcp_fd = fd;        

    /*/dev/ppp INTERFACE 
    make_ppp_unit中第一创建*/
    ppp_cfg[unit]-&gt;ppp_fd =  ppp_info-&gt;ppp_dev_fd;
</code></pre>
<p>​    之所以列出此结构,是因为ppp启动状态机之前的所有初始化都和此配置相关.</p>
<p>​    我们初始化时可以利用此结构依次初始化.</p>
<h4 id="pppd相关结构体"><a href="#pppd相关结构体" class="headerlink" title="pppd相关结构体"></a>pppd相关结构体</h4><pre><code class="c">/*我们自己定义用于保存ppp配置*/
struct pptp_ppp_channel
{
    int ppp_dev_fd;    
    int ifunit;            /* Interface unit number */
    int ioctl_fd;            /*for ioctl*/
    struct thread *cdma_rth;
    struct thread *cdma_idle_tth;
    struct thread *at_rth;
    struct thread *at_tth;
    struct thread *auto_down_dial;
    list pkt_list;
    int ttyfd;
    int state;
    char user[256];    /* Username for authentication */
    char passwd[256];    /* Password for authentication */
    struct prefix_ipv4 local_addr;
    u8     distance;
    u8     weight;
    u8     gateway;
    u8     dns;
    int idle_time;
};
/*pppd状态机用到的结构体*/
struct ppp_info
{
    int unit;
    int dev_fd;
    int lcp_fd;
    int ppp_fd;
    int remote_id;
    char    *user;    /* Username for authentication */
    char    *passwd;    /* Password for authentication */
    char *ifname;
    char attach_inter[16];
    unsigned char distance;
    unsigned char weight;
    unsigned char gateway;
    unsigned char dns;
    unsigned char auth;
    unsigned char auth_type;
    unsigned char down_flag;    
    unsigned int unique;
    unsigned int dns_value;
    unsigned int wins_value;
    char usergrp[MAXNAMELEN];
    struct prefix_ipv4 localaddr;
    unsigned int peer_address;//tunnip
    int lcp_detect_interval_time;        
    int lcp_detect_lost_times;        
    struct thread * lcp_thread;
    struct thread * ipcp_rthread;
    void *conn;
    void *priv_data;
    int natid;
    int mtu;
    Ppp_if_type iftype;
    int (*manage_auto_down) (char *ifname);
    int (*ipcp_up_cb) (struct ppp_cb_info *cb_info);
    int (*ipcp_down_cb) (struct ppp_cb_info *cb_info);
    int (*lcp_auth) (char *name, char *group, char *password, unsigned char *challenge, int unit, int type);
    int (*check_rqci)(__u32 addr);
};
</code></pre>
<h3 id="pppd协议初始化原理代码"><a href="#pppd协议初始化原理代码" class="headerlink" title="pppd协议初始化原理代码"></a>pppd协议初始化原理代码</h3><h4 id="pppd对tty做规程绑定"><a href="#pppd对tty做规程绑定" class="headerlink" title="pppd对tty做规程绑定"></a>pppd对tty做规程绑定</h4><pre><code class="c">/* The PPP discpline */
static int ppp_disc = N_PPP;    

int tty_establish_ppp (int devfd)
{
    /*绑定tty规程*/
    if (ioctl(devfd, TIOCSETD, &amp;ppp_disc) &lt; 0)
    ret_fd = generic_establish_ppp(devfd);
}
</code></pre>
<h4 id="pppd绑定对应pty-chindex"><a href="#pppd绑定对应pty-chindex" class="headerlink" title="pppd绑定对应pty_chindex"></a>pppd绑定对应pty_chindex</h4><pre><code class="c">//例
void start_link(unit)
{
    /*调用connect_tty*/
    devfd = the_channel-&gt;connect();
    /*调用tty_establish_ppp*/
    fd_ppp = the_channel-&gt;establish_ppp(devfd);
}

int connect_tty()
{
    /*char ppp_devnam[MAXPATHLEN]; //name of PPP tty*//
    get_pty(&amp;pty_master, &amp;pty_slave, ppp_devnam, uid);
    return pty_slave;
}

int tty_establish_ppp (int tty_fd)
{
    /*对tty做规程绑定*/
    if (ioctl(devfd, TIOCSETD, &amp;ppp_disc) &lt; 0)
    /*通过/dev/ppp设置channel*/
    ret_fd = generic_establish_ppp(tty_fd);
}
int generic_establish_ppp (int devfd)
{
    /*通过/dev/pty/n获取channel id*/
    if (ioctl(devfd, PPPIOCGCHAN, &amp;chindex) == -1)
    /*打开&quot;/dev/ppp&quot;*/
    fd = open(&quot;/dev/ppp&quot;, O_RDWR)
    /*设置channel 到/dev/ppp*/
    if (ioctl(fd, PPPIOCATTCHAN, &amp;chindex) &lt; 0)
}
</code></pre>
<h4 id="pppd协议发送接口初始化"><a href="#pppd协议发送接口初始化" class="headerlink" title="pppd协议发送接口初始化"></a>pppd协议发送接口初始化</h4><pre><code class="c">static int make_ppp_unit(struct cdma_ppp_channel *ppp_info)
{
    ppp_dev_fd = open(&quot;/dev/ppp&quot;, O_RDWR);
    x = ioctl(ppp_dev_fd, PPPIOCNEWUNIT, &amp;req);
      ppp_info-&gt;ppp_dev_fd = ppp_dev_fd;
}

int cdma_setup_ppp(struct cdma_ppp_channel *ppp_info)
{
      fd = open(&quot;/dev/ppp&quot;, O_RDWR);
    if (ioctl(fd, PPPIOCATTCHAN, &amp;chindex);
    if (ioctl(fd, PPPIOCCONNECT, &amp;ppp_info-&gt;ifunit);

    ppp_cfg[unit]-&gt;dev_fd = ppp_info-&gt;ttyfd;
    ppp_cfg[unit]-&gt;lcp_fd = fd;
    ppp_cfg[unit]-&gt;ppp_fd = ppp_info-&gt;ppp_dev_fd;
}

void output (int unit, unsigned char *p, int len)
{
  int fd = ppp_cfg[unit]-&gt;lcp_fd;

  if (ppp_cfg[unit]-&gt;ppp_fd &gt;= 0 &amp;&amp; !(proto &gt;= 0xc000 || proto == PPP_CCPFRAG))
        fd = ppp_cfg[unit]-&gt;ppp_fd;

  if (write(fd, p, len) &lt; 0)
}
</code></pre>
<h3 id="pppd协议-转状态机原理"><a href="#pppd协议-转状态机原理" class="headerlink" title="pppd协议/转状态机原理"></a>pppd协议/转状态机原理</h3><h4 id="pppd状态机框图"><a href="#pppd状态机框图" class="headerlink" title="pppd状态机框图"></a>pppd状态机框图</h4><p><img src="ppp状态机.jpeg" alt=""></p>
<p><img src="ppp协商.jpeg" alt=""></p>
<h4 id="pppd状态机启动代码"><a href="#pppd状态机启动代码" class="headerlink" title="pppd状态机启动代码"></a>pppd状态机启动代码</h4><pre><code class="c">int cdma_setup_ppp(struct cdma_ppp_channel *ppp_info){
    magic_init();
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
        (*protp-&gt;init)(unit);
    new_phase(unit,PHASE_ESTABLISH);
    lcp_lowerup(unit);
    lcp_open(unit);        /* Start protocol */
    ppp_cfg[unit]-&gt;lcp_thread = thread_add_read(master, pppd_read, (void *)unit, fd);
    ppp_cfg[unit]-&gt;ipcp_rthread = thread_add_read(master, pppd_read, (void *)unit,  ppp_info-&gt;ppp_dev_fd);
}
</code></pre>
<h4 id="pppd协议发包流程"><a href="#pppd协议发包流程" class="headerlink" title="pppd协议发包流程"></a>pppd协议发包流程</h4><pre><code class="c">//ppp_generic.c
//ppp_xmit_process 通过虚拟网口
//ppp_channel_push 通过tty

switch (cmd) {
case PPPIOCNEWUNIT:
ppp = ppp_create_interface(net, unit, &amp;err);
file-&gt;private_data = &amp;ppp-&gt;file;
}
ppp_write(){
struct ppp_file *pf = file-&gt;private_data;
switch (pf-&gt;kind) {
case INTERFACE:
    ppp_xmit_process(PF_TO_PPP(pf));
    break;
case CHANNEL:
    ppp_channel_push(PF_TO_CHANNEL(pf));
    break;
}
</code></pre>
<h4 id="虚拟网口发包流程"><a href="#虚拟网口发包流程" class="headerlink" title="虚拟网口发包流程"></a>虚拟网口发包流程</h4><pre><code>ppp_start_xmit-&gt;ppp_xmit_process-&gt;
ppp_push调用pch-&gt;chan-&gt;ops-&gt;start_xmit发送数据包。    
ppp_asynctty_open中注册的ppp_async_send函数，    
---规程层---
ppp_async_send经ppp_async_push函数调用
tty-&gt;driver-&gt;write把数据发送串口
---驱动层---
pty_ops
</code></pre><p>例如:tty-&gt;driver-&gt;write为pty_ops中的write   </p>
<pre><code class="c">//注:其中pty-master可以理解为tty硬件层
//内核中pty.c 设置驱动层操作函数
pty_init()
{
    tty_set_operations(pty_driver, &amp;pty_ops);
}
//pppd为以上pty和disc做了绑定
//也就是驱动层到规程层关联
int tty_establish_ppp (int devfd)
{
    /*绑定tty规程*/
    if (ioctl(devfd, TIOCSETD, &amp;ppp_disc) &lt; 0)
    ret_fd = generic_establish_ppp(devfd);
}
//其中channel_id为以上操作标识
</code></pre>
<h4 id="ppp-channel-push-PF-TO-CHANNEL-pf"><a href="#ppp-channel-push-PF-TO-CHANNEL-pf" class="headerlink" title="ppp_channel_push(PF_TO_CHANNEL(pf))"></a>ppp_channel_push(PF_TO_CHANNEL(pf))</h4><pre><code>        ppp = ppp_create_interface(net, unit, &amp;err);
        if (!ppp)
            break;
        file-&gt;private_data = &amp;ppp-&gt;file;
</code></pre><h4 id="ppp-xmit-process-PF-TO-PPP-pf"><a href="#ppp-xmit-process-PF-TO-PPP-pf" class="headerlink" title="ppp_xmit_process(PF_TO_PPP(pf))"></a>ppp_xmit_process(PF_TO_PPP(pf))</h4><pre><code>        ppp = ppp_create_interface(net, unit, &amp;err);
        if (!ppp)
            break;
        file-&gt;private_data = &amp;ppp-&gt;file;
</code></pre><p>ppp_设置网口ip</p>
<h2 id="pptp原理与设计"><a href="#pptp原理与设计" class="headerlink" title="pptp原理与设计"></a>pptp原理与设计</h2><p>值得一提的是 ppp的LCP协商Configure-Request,是在pptp中发的.</p>
<pre><code class="c">数据结构:
pptp_cfg
{
    int instance_id;
    int gre_fd;
    int tty_fd;
    int call_id;
    int peer_call_id;
    char username[];
    char password[];
}
操作函数:
启动
1. 创建gre_fd
2. 创建tty_fd;
3. 通过pptp协商获取call_id
4. 启动gre_copy线程
5. 执行ppp协商,创建虚拟接口
关闭
1. 协商断开ppp连接, 协商断开pptp连接.
2. 关闭虚拟接口
2. gre_copy通过pptp_cfg标记退出线程并释放对应pptp_cfg
</code></pre>
<h2 id="PPTP模块简易软件设计"><a href="#PPTP模块简易软件设计" class="headerlink" title="PPTP模块简易软件设计"></a>PPTP模块简易软件设计</h2><ol>
<li>改造PPTP</li>
<li>初始化PPPD相关设置</li>
<li>启动PPPD状态机</li>
</ol>
<h2 id="PPTP软件设计方案"><a href="#PPTP软件设计方案" class="headerlink" title="PPTP软件设计方案"></a>PPTP软件设计方案</h2><h3 id="多实例原理与设计"><a href="#多实例原理与设计" class="headerlink" title="多实例原理与设计"></a>多实例原理与设计</h3><p>考虑多实例, 可以把每个实例运行一个线程. </p>
<ol>
<li><p>多线程问题,就要考虑:<br><strong>全局变量</strong> <strong>互斥条件</strong> <strong>执行顺序</strong> <strong>信号</strong> 等.<br>pptp 本身是多进程实现多个连接,<br>所以想要多线程实现多个连接, 还需解决变量问题.  </p>
</li>
<li><p>也可以用多进程实现多实例<br>但是又要考虑控制进程时,需要进程间通信.  </p>
</li>
<li><p>多进程合并为线程和合并pppd需要考虑信号, 输入输出等问题.</p>
</li>
</ol>
<p>pptp 完成二层点对点通道<br>ppp 完成三层ip通道</p>
<p>一. 完成pppd和pptp的整合, 使pptp可以和pppd.a编译在一起运行.  </p>
<pre><code>    1.分析pppd原理.  
        包含:pppd 利用/dev/ppp0字符设备,通过内核到pptp_gre. 
        这需要分析内核的实现.  
    2.分析pptp原理.
</code></pre><p>二. 完成pptp初始化和二层点对点环境的建立.</p>
<p>三. 完成cli的demon融合</p>
<p>接口描述：</p>
<pre><code>pptp_init    : 1.初始化pptp默认参数 2.开启ctrl
pptp_set     : 1.设置定制参数 
pptp_enable : 1. Ctrl连接, Gre隧道建立, 获取call_id
              2. 开启ppp任务, 开启copy功能任务
pptp_disable: 1. 关闭ppp任务, 关闭copy功能 
</code></pre><pre><code>1. Ctrl连接, Gre隧道断开任务
     pppd通过字符设备/dev/ppp 和内核通信和发送协商报文
</code></pre><p>通过以上字符设备实现,发现ppp内核字符设备就一个.<br>如果要多个要注册多个ppp字符设备.<br>并且发送协商报文出口是在字符设备的私有数据段中.</p>
<p>pppd主要完成功能:<br>1.链路协商<br>2.创建虚拟接口</p>
<p>链路协商需要提供:</p>
<p>创建虚拟接口提供:</p>
<p>pppd输入: 1.pptp参数 2.pptp协商后信息<br>pppd输出: 1.设置虚拟接口</p>
<ol>
<li>其中启动ppp任务,pptp需要传入tty_fd相关信息</li>
</ol>
<p>pppd接口 </p>
<ol>
<li>l2tp_setup_pppd</li>
<li>establlish_session</li>
</ol>
<p>pppd所有配置参数</p>
<pre><code class="c">typedef struct {
    char    *name;        /* name of the option */
    enum opt_type type;
    void    *addr;
    char    *description;
    unsigned int flags;
    void    *addr2;
    int    upper_limit;
    int    lower_limit;
    const char *source;
    short int priority;
    short int winner;
} option_t;
</code></pre>
<p>pppd中的ppp_main.c<br>中的main函数改为ppp_setup只是避免main冲突和做参考,并没有用.</p>
<p>真正的pppd启动函数在l2tp中模仿之前的main函数改为l2pd_pppox.c中<strong>l2tp_setup_pppd</strong></p>
<p>l2tp_peer 是用来和对端通信的接口</p>
<p>ppp_ioctl  配置了ppp_channel *chan<br>ppp_write  </p>
<p>移植<br>l2tp_ppp(sync_pppd) -&gt; pptp_ppp<br>l2tp_pppox -&gt; pptp_pppox   </p>
<h3 id="命令行原理与设计"><a href="#命令行原理与设计" class="headerlink" title="命令行原理与设计"></a>命令行原理与设计</h3><p>如果需要多实例,则全局pptp配置连接 pptp守护进程.</p>
<p>守护进程只负责创建实例删除实例.</p>
<h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><h4 id="第一阶段-开源验证"><a href="#第一阶段-开源验证" class="headerlink" title="第一阶段: 开源验证"></a>第一阶段: 开源验证</h4><p>​    实现pptp, pppd分离启动<br>​    /<em>唯一需要修改的是pptp在pty_read地方,<br>​    发现pppd为启动则continue</em>/<br>​    pptp 和pppd 开源独立测试<br>​    ./pptp 192.168.2.12<br>​    ./pppd /dev/pts/2 unit 1 user test@hfdzzp.vpdn.zj password test135</p>
<h4 id="第二阶段-简单demo"><a href="#第二阶段-简单demo" class="headerlink" title="第二阶段: 简单demo"></a>第二阶段: 简单demo</h4><p>​    实现pptp融合我们系统中的pppd库<br>​    /<em>实现简单的demo, 只是能ping通即可</em>/<br>​    /<em>在测试中发现 必须以协议的方式下发ip,<br>​    不能以以下方式设置,还不知道有何区别</em>/<br>​    ifconfig pptp0 up<br>​    ifconfig pptp0 192.168.210.10   //此方法配置ip不可行 必须以api的方式配置<br>​    route add -net 192.168.210.0 netmask 255.255.255.0 pptp0</p>
<h4 id="第三阶段-设计方案"><a href="#第三阶段-设计方案" class="headerlink" title="第三阶段: 设计方案"></a>第三阶段: 设计方案</h4><p>​    继续分析ppp相关代码,实现优化方案</p>
<p>​    多实例?</p>
<h4 id="第四阶段-实现代码"><a href="#第四阶段-实现代码" class="headerlink" title="第四阶段: 实现代码"></a>第四阶段: 实现代码</h4><h4 id="第五阶段-测试功能"><a href="#第五阶段-测试功能" class="headerlink" title="第五阶段: 测试功能"></a>第五阶段: 测试功能</h4><h2 id="还未掌握内容"><a href="#还未掌握内容" class="headerlink" title="还未掌握内容"></a>还未掌握内容</h2><ol>
<li>unit /channel_id / struct ppp /struct ppp_file 等千丝万缕的关系.</li>
</ol>
<p>pppd初始化流程start_link</p>
<p>第一步: 通过connect_tty拿到pty_client_fd</p>
<p>第二步: 通过tty_establish_ppp做规程绑定</p>
<p>callmgr_main-&gt;pptp_dispatch-&gt;pptp_handle_timer</p>
<p>断开后 应该退出pptp_ctrl进程 和 ppp线程</p>
<p>断开重连 应该再次pptp协商 和ppp协商</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p>​    <a href="http://blog.csdn.net/lizuobin2/article/details/51773305" target="_blank" rel="external">tty初探—uart驱动框架分析</a></p>
<p>​    <a href="http://blog.csdn.net/wt0427/article/details/7761163" target="_blank" rel="external">Linux PPP详细介绍</a></p>
<p>​    <a href="http://linux.chinaunix.net/techdoc/system/2008/11/07/1043935.shtml" target="_blank" rel="external">Linux PPP 数据收发流程</a></p>

      
    </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/NETWORK/Linux PPP 框架分析.html">
      Linux PPP 框架分析
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://demonelf.github.io" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>madhex</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2017-08-15</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/NETWORK/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>NETWORK</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <ol>
<li>介绍</li>
</ol>
<p>通过对Linux源代码的分析,了解PPP设备在linux内的工作原理.顺便了解一下PPPoE如何利用PPP设备来完成上网的工作的.下面是代码研究的基础版本：</p>
<p>Software      version<br>Linux内核    2.6.15<br>PPPd    ppp-2.4.3<br>PPPoE    rp-pppoe-3.8</p>
<ol>
<li><p>PPP相关模块及结构</p>
<p><img src="PPP框架原理.jpg" alt=""></p>
</li>
</ol>
<p>注：每个模块左上角或右上角蓝色字体的数字是用来方便区别每个模块。</p>
<p>每个层次及工作在该层次的程序（模块）分析如下：</p>
<p>2.1 应用层模块概述</p>
<p>工作在该层的模块编号：（1）Pppd、（2）Pppoe、（10）网络应用程序</p>
<p>2.1.1   Pppd</p>
<p>使用源代码ppp-2.4.3编译生成，该程序用来完成PPP过程（lcp/pap/chap/ipcp等）的应用程序.它和Pppoe两个用户态应用程序配合起来,可以完成PppOe的拨号上网的链路协商及维护.</p>
<p>熟悉Ppp相关协议的知道,Ppp链路协商过程有LCP/PAP/CHAP/PAP等很多协议.这些包会经由协议栈分类,提交到字符设备/dev/ppp0的队列中.而Pppd这个应用程序,就是从ppp0中将这些包读取出来,然后递交到各协议的子过程中去处理,从而在应用态完成这些协议的处理过程.</p>
<p>这里需要提一点,要想深入的理解Pppd应用程序的工作方法,必须要了解字符设备ppp0是如何工作的.</p>
<p>2.1.2   Pppoe</p>
<p>首先,pppoe完成了PPPoE Discovery过程,这个过程很简单,只有PADI/PADO, PADR/PADS四个包.主要目的是相互告知MAC地址.</p>
<p>另外,这个程序负责接收和发送Pppoe链路的所有数据包,包括ppp协议过程的数据包,也包括正常网络应用通过网络接口ppp发送的TCP/IP数据包.在此需要了解类型为0x8863/0x8864的Socket如何工作,另外需要了解数据包如何通过PTY设备在Pppoe和PPP协议栈之间传递的.在内核模块概述中会给予描述.</p>
<p>所以,我们可以将pppoe应用程序作为拨号链接进入主机的入口,所有的数据包都经由它进入主机.</p>
<p>2.1.3   网络应用程序</p>
<p>这里指一般网络应用，比如上网、下载等。主要作用是描述普通数据包的行走路径.</p>
<p>2.2 内核层模块概述</p>
<p>工作在该层的模块编号：（3）/dev/ppp%n、（4）TCP/IP协议栈、（5）Socket、（6）PPP协议栈、（7）PTY设备、（8）ETH1</p>
<p>2.2.1   /dev/ppp%n</p>
<p>该设备需要打开内核支持,可以make menuconfig选择相应的子项,另外需要在/dev目录下创建主设备号为108从设备号为0的字符设备才可以在用户态使用.</p>
<p>创建了ppp设备后，ppp过程的数据包经过协议栈的分类,会被送到该接口的队列内.用户态应用程序(如pppd)从该接口内读取ppp过程的数据包，然后送交相应的协议栈处理.对于响应的数据包,同样可以写入到该设备中,设备内会将数据包送交协议栈然后转发出去.</p>
<p>2.2.2   TCP/IP协议栈</p>
<p>普通Linux TCP/IP协议栈.</p>
<p>2.2.3   Socket</p>
<p>PppOe Session和Discovery数据包对应的以太网类型分别为0x8863/0x8864,因为这两种类型的数据包是由Pppoe应用程序通过Socket来收发的,所以内核中需要定义这两种类型的Socket.这两个Socket内核处理非常简单,只做了最基本的检查便由Pppoe收取上来.</p>
<p>2.2.4   PPP协议栈</p>
<p>主要负责PPP层数据的封装、压缩与解压缩.另外,它还对普通数据包和Ppp过程的数据包进行了分流,将普通数据包提交到TCP/IP协议栈,而将Ppp过程的数据包放到/dev/ppp设备队列中,等待Pppd去收取并处理.</p>
<p>2.2.5   PTY设备</p>
<p>串行设备，PPP内核协议栈与pppoe应用程序的中转站.因为Ppp协议早多运行在串行链路上,所以在Linux内核中PPP协议栈与串行设备结合紧密.</p>
<p>2.2.6   Eth1</p>
<p>这里是指连接以太网的出口,用来表示数据包路径而引入.</p>
<p>2.3 物理层模块概述</p>
<p>工作在该层的模块编号：（9）以太网驱动</p>
<ol>
<li>PPPoE拨号建立的过程</li>
</ol>
<p>从拨号链接开始到用户可以上网主要分三个过程：</p>
<p>Ø PPPoE Discovery过程</p>
<p>Ø PPP过程</p>
<p>Ø 设置上网主机</p>
<p>3.1 PPPoE Discovery 过程</p>

      
    </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/NETWORK/linux 下创建GRE隧道.html">
      linux 下创建GRE隧道
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://demonelf.github.io" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>madhex</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2017-08-15</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/NETWORK/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>NETWORK</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>其他国家的互联网如同一个孤岛。要想访问国外网站异常的缓慢，甚至被和谐了。可以建立一条隧道来避免这种情况，下面说说GRE隧道如何建立。</p>
<ol>
<li>GRE介绍<br>GRE隧道是一种IP-over-IP的隧道，是通用路由封装协议，可以对某些网路层协议的数据报进行封装，使这些被封装的数据报能够在IPv4/IPv6 网络中传输。<br>Tunnel 是一个虚拟的点对点的连接，提供了一条通路使封装的数据报文能够在这个通路上传输，并且在一个Tunnel 的两端分别对数据报进行封装及解封装。　一个X协议的报文要想穿越IP网络在Tunnel中传输，必须要经过加封装与解封装两个过程。<br>要在Linux上创建GRE隧道，需要ip_gre内核模块，它是GRE通过IPv4隧道的驱动程序。</li>
<li>查看是否有加载ip_gre模块<pre><code># modprobe ip_gre
# lsmod | grep gre
ip_gre                 22432  0
gre                    12989  1 ip_gre
# modprobe ip_gre
# lsmod | grep gre
ip_gre                 22432  0
gre                    12989  1 ip_gre
</code></pre></li>
<li>创建步骤<br>环境如下：<br>host A :  121.207.22.123<br>host B: 111.2.33.28<br>在host A上面：<pre><code># ip tunnel add gre1 mode gre remote 111.2.33.28 local 121.207.22.123 ttl 255
# ip link set gre1 up
# ip addr add 10.10.10.1 peer 10.10.10.2 dev gre1
# ip tunnel add gre1 mode gre remote 111.2.33.28 local 121.207.22.123 ttl 255
# ip link set gre1 up
# ip addr add 10.10.10.1 peer 10.10.10.2 dev gre1
</code></pre>创建一个GRE类型隧道设备gre0, 并设置对端IP为111.2.33.28。隧道数据包将被从121.207.22.123也就是本地IP地址发起，其TTL字段被设置为255。隧道设备分配的IP地址为10.10.10.1，掩码为255.255.255.0。<br>在host B上面：<pre><code>#  ip tunnel add gre1 mode gre remote  121.207.22.123 local 111.2.33.28 ttl 255
#  ip link set gre1 up
#  ip addr add 10.10.10.2 peer 10.10.10.1 dev gre1
#  ip tunnel add gre1 mode gre remote  121.207.22.123 local 111.2.33.28 ttl 255
#  ip link set gre1 up
#  ip addr add 10.10.10.2 peer 10.10.10.1 dev gre1
</code></pre>此时，host A 和 host B 建立起GRE隧道了。</li>
<li>检测连通性</li>
</ol>
<pre><code># ping 10.10.10.2 (host A)
PING 10.10.10.2 (10.10.10.2) 56(84) bytes of data.
64 bytes from 10.10.10.2: icmp_req=1 ttl=64 time=0.319 ms
64 bytes from 10.10.10.2: icmp_req=2 ttl=64 time=0.296 ms
64 bytes from 10.10.10.2: icmp_req=3 ttl=64 time=0.287 ms
# ping 10.10.10.2 (host A)
PING 10.10.10.2 (10.10.10.2) 56(84) bytes of data.
64 bytes from 10.10.10.2: icmp_req=1 ttl=64 time=0.319 ms
64 bytes from 10.10.10.2: icmp_req=2 ttl=64 time=0.296 ms
64 bytes from 10.10.10.2: icmp_req=3 ttl=64 time=0.287 ms
</code></pre><ol>
<li>撤销GRE隧道<br>在任一一端操作下面命令<pre><code># ip link set gre1 down
# ip tunnel del gre1
# ip link set gre1 down
# ip tunnel del gre1
</code></pre>转载请注明来自运维生存时间: <a href="http://www.ttlsa.com/html/4138.html" target="_blank" rel="external">http://www.ttlsa.com/html/4138.html</a></li>
</ol>

      
    </div>
    
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
      <br>
      <div class="prev-next">
        <div class="prev-next">
          
          <p class="current">
            1 / 2
          </p>
          
            <a class="next" rel="next" href="/categories/NETWORK/page/2/">
              <section class="post next">
                &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
              </section>
            </a>
          
        </div>
      </div>

    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


    
  

</div>
<aside class='l_side'>
  
    
    
      
        
          
          
            <section class='widget author'>
  <div class='content pure'>
    
      <div class='avatar'>
        <img class='avatar' src='http://bbs.dnsnat.com/discuz/uc_server/data/avatar/000/00/00/01_avatar_big.jpg'/>
      </div>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:me@xaoxuu.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/xaoxuu"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=63035382"
              class="social fas fa-headphones-alt flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

          
        
      
        
          
          
            

          
        
      
        
          
          
            <section class='widget grid'>
  
<header class='pure'>
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class='content pure'>
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/"
          
          
          id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/blog/archives/" href="/blog/archives/"
          
            rel="nofollow"
          
          
          id="blogarchives">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
        <li><a class="flat-box" title="/projects/" href="/projects/"
          
          
          id="projects">
          
            <i class="fas fa-code-branch fa-fw" aria-hidden="true"></i>
          
          开源项目
        </a></li>
      
        <li><a class="flat-box" title="/friends/" href="/friends/"
          
            rel="nofollow"
          
          
          id="friends">
          
            <i class="fas fa-link fa-fw" aria-hidden="true"></i>
          
          我的友链
        </a></li>
      
        <li><a class="flat-box" title="https://xaoxuu.com/wiki/material-x/" href="https://xaoxuu.com/wiki/material-x/"
          
            rel="nofollow"
          
          
          id="https:xaoxuu.comwikimaterial-x">
          
            <i class="fas fa-book fa-fw" aria-hidden="true"></i>
          
          主题文档
        </a></li>
      
        <li><a class="flat-box" title="/about/" href="/about/"
          
            rel="nofollow"
          
          
          id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于小站
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            
  <section class='widget category'>
    
<header class='pure'>
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/categories/"
    title="categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/DEVELOP/" href="/categories/DEVELOP/"><div class='name'>DEVELOP</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box" title="/categories/EMBEDDED/" href="/categories/EMBEDDED/"><div class='name'>EMBEDDED</div><div class='badge'>(95)</div></a></li>
        
          <li><a class="flat-box child" title="/categories/EMBEDDED/mini2440/" href="/categories/EMBEDDED/mini2440/"><div class='name'>mini2440</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/LIVE/" href="/categories/LIVE/"><div class='name'>LIVE</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box" title="/categories/NETWORK/" href="/categories/NETWORK/"><div class='name'>NETWORK</div><div class='badge'>(12)</div></a></li>
        
          <li><a class="flat-box" title="/categories/SYSTEM/" href="/categories/SYSTEM/"><div class='name'>SYSTEM</div><div class='badge'>(12)</div></a></li>
        
          <li><a class="flat-box" title="/categories/VPN系列之五花八门/" href="/categories/VPN系列之五花八门/"><div class='name'>VPN系列之五花八门</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/arm/" href="/categories/arm/"><div class='name'>arm</div><div class='badge'>(0)</div></a></li>
        
          <li><a class="flat-box" title="/categories/embedded/" href="/categories/embedded/"><div class='name'>embedded</div><div class='badge'>(0)</div></a></li>
        
          <li><a class="flat-box" title="/categories/linux/" href="/categories/linux/"><div class='name'>linux</div><div class='badge'>(0)</div></a></li>
        
          <li><a class="flat-box" title="/categories/笑看人生/" href="/categories/笑看人生/"><div class='name'>笑看人生</div><div class='badge'>(0)</div></a></li>
        
      </ul>
    </div>
  </section>


          
        
      
        
          
          
            
  <section class='widget tagcloud'>
    
<header class='pure'>
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/blog/tags/"
    title="blog/tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <a href="/tags/linux/" style="font-size: 14px; color: #999">linux</a>
    </div>
  </section>


          
        
      
        
          
          
            


  <section class='widget music'>
    
<header class='pure'>
  <div><i class="fas fa-compact-disc fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;最近在听</div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_blank"
    
    href="https://music.163.com/#/user/home?id=63035382"
    title="https://music.163.com/#/user/home?id=63035382">
    <i class="far fa-heart fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css">
  <div class="aplayer"
    data-theme="#1BCDFC"
    
    
    data-mode="circulation"
    data-server="netease"
    data-type="playlist"
    data-id="2615636388"
    data-volume="0.7">
  </div>
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script>


    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="/atom.xml"
            class="social fas fa-rss flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="mailto:me@xaoxuu.com"
            class="social fas fa-envelope flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/xaoxuu"
            class="social fab fa-github flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://music.163.com/#/user/home?id=63035382"
            class="social fas fa-headphones-alt flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
</footer>
<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>




  
  
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        if ('.cover') {
          $('.cover').backstretch(
          ["https://img.vim-cn.com/6d/a0c9e6f9efad8b731cb7376504bd10d79d2053.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        } else {
          $.backstretch(
          ["https://img.vim-cn.com/6d/a0c9e6f9efad8b731cb7376504bd10d79d2053.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        }
      });
    </script>
  











  <script src="/js/app.js"></script>


  <script src="/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>
</body>
</html>
